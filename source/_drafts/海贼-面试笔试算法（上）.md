---
title: 海贼 面试笔试算法（上）
categories:
  - []
tags:
  - null
---

<!--more-->

## 2020-10-28
### 滑动窗口
静态窗口：
动态窗口：双指针；

### 方向数组

### 记忆数组

递归 + 记忆数组

## 2020-10-30

大数相加， 大数相乘， 大数相除

动态规划
- euler25
- euler15
  - 从上到下；
  - 从下到上 is better；

海贼oj 590

## 2020-11-1


### 排序

### 二分查找
二分查找：
- 整数二分
- 浮点二分


二分最优化问题
- 确定是 00001111 还是 11110000；
- 确定上下界；
- 针对 00000000 情况：可以特判，可以虚拟头/尾指针；

0000011111（保留右边）
- p != r;
- q = p + r >> 1;
- p = q + 1;
- r = q;

1111100000（保留左边）
- p != r;
- q = p + r + 1 >> 1;
- p = q;
- r = q - 1;


## 2020-11-4

vimtutor

替换
- %s/","/ /g

判断一个数多少位；
- floor(log10(x)) + 1;

### 两数之和
- 暴力
- 哈希
- 双指针法（推荐）

### 杨式矩阵
- 反对角线查找

## 2020-11-6

### leetcode
- 9
- 13
- 14
- 35
- 38
- 53
- 66
- 67
- 70
- 88
- 118
- 119
- 121
- 122
- 136
- 125

## 2020-11-8

### 海贼OJ
- 477
- 479
- 480
- 481
- 484
- 485
- 505
- 506
- 508
- 509
- 518
- 515

## 2020-11-11

栈和队列的底层实现是 deque （容器，栈和队列都是适配器）
- stack / queue ： 底层 deque；
- vector:底层数组；
- priority_queue: 堆，需要重载 operator<;
- string: 
- map:底层红黑树，键值需要重载operator<;
- unordered_map:底层哈希，键需要重hash函数；
- set:
- pair:
### 海贼OJ
- 519

## 2020-11-15
排列组合

递归 + 回溯

### 海贼OJ
- 240
- 235
- 236
- 237

搜索
- 深搜

搜索 + 回溯

深搜走地图：
- 判断能否从起点走到终点；

### 海贼OJ
- 535

## 2020-11-22
### 海贼OJ
537
```cpp


```
## 1 编码能力提升
### 1.1 Euler 8. 连续数字最大乘积
滑动窗口法
- 静态窗口：
- 动态窗口：又叫双指针法；

```cpp
#include <iostream>
using namespace std;

char str[1005];
int ans, zero_cnt, now = 1;

int main() {
    cin >> str;
    for(int i = 0; i < 1000; ++i) {
        if(i < 13) {
            now *= num[i] - '0';
        } else {
            if(num[i] == '0') {
                ++zero_cnt;
            } else {
                now *= num[i] - '0';
            }
            if(num[i - 13] == '0') {
                --zero_cnt;
            } else {
                now /= num[i - 13] - '0';
            }
        }
        if(zero_cnt == 0) {
            ans = max(ans, now);
        }
    }
    cout << ans << endl;
    return 0;
}
```

### 1.2 Euler 11.方阵中的最大乘积
方向数组
```c
//上下左右四个方向
int dir[4][2] = {-1， 0， 0， 1， 1， 0， 0， -1}；

//上下左右，左上左下右上右下八个方向
int dir[8][2] = {-1, 0, 0, 1, 1, 0, 0, -1, -1, -1, -1, 1, 1, 1, 1, -1};
```
边界问题
- 处理方法一：判断是否越界；
- 处理方法二：外界补“零”；
```cpp
#include <iostream>
using namespace std;
int dir[4][2] = {0, 1, 1, 1, 1, 0, 1, -1};
int num[30][30], ans;

int main() {
    for(int i = 5; i < 25; ++i) {
        for(int j = 5; j < 25; ++j) {
            cin >> num[i][j];
        }
    }
    for(int i = 5; i < 25; ++i) {
        for(int j = 5; j < 25; ++j) {
            for(int k = 0; k < 4; ++k) {
                int temp = num[i][j];
                for(int t = 1； t < 4; ++t) {
                    int x = i + dir[k][0] * t;
                    int y = i + dir[k][1] * t;
                    temp *= num[x][y];
                }
                ans = max(ans, temp);
            }
        }
    }
    cout << ans << endl;
    return 0;
}
```

### 1.3 Euler 14.最长考拉兹序列
引入：
- 菲波那契数列递归实现存在的问题，重复计算，导致效率低下；

递归 + 记忆数组 约等于 迭代：
- 每个子问题只计算一次，计算完成将子问题答案进行记录；
- 后面遇到相同子问题，查找记忆数组即可，不必再重新计算子问题；
```cpp
//递归
#include <iostream>
using namespace std;

long long fibonacci(int n) {
    if(n == 1 || n == 2) return 1;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

int main() {
    for(int i = 1; i < 40; ++i) {
        cout << i << " : " << fibonacci(i) << endl;
    }
    return 0;
}

//递归 + 记忆数组
#include <iostream>
using namespace std;

long long num[50];

long long fibonacci(int n) {
    if(n == 1 || n == 2) return 1;
    if(num[n]) return num[n];
    return num[n] = fibonacci(n - 1) + fibonacci(n - 2);
}

int main() {
    for(int i = 1; i < 40; ++i) {
        cout << i << " : " << fibonacci(i) << endl;
    }
    return 0;
}
```

问题分析
- 数可能很大，数组需要开得很大；
- 数组也可能越界；

```cpp
#include <iostream>
using namespace std;

int num[10000000];

int func(int x) {
    if(x == 1) return 1;
    if(n < 10000000 && num[n]) return num[n];
    int t = 0;
    if(n % 2 == 0) {
        t = func(n / 2) + 1;
    } else {
        t = func(3 * n + 1) + 1;
    }
    if(n < 10000000) {
        num[n] = t;
    }
    return t;

}

int main() {
    int ans = 1;
    for(int i = 2; i < 100000; ++i) {
        if(func(ans) < func(i)) {
            ans = i;
        }
    }
    cout << ans << endl;
    return 0;
}
```
### 1.4 Euler 13. 大整数加法
```cpp
#include <iostream>
#include <string>
using namespace std;

string add(const string &a, const string &b) {
    string s = a.size() < b.size() ? a : b;
    const string &t = a.size() < b.size() ? b : a;

    s = string(t.size() - s.size(), '0') + s;

    int n = t.size();
    int carry = 0;
    for(int i = n; i >= 0; --i) {
        int temp = s[i] - '0' + t[i] - '0' + carry;
        s[i] = temp % 10 + '0';
        carry = temp / 10;
    }
    return carry ? "1" + s : s;
}

int main() {

    return 0;
}
```
### 1.5 Euler 25. 一千位斐波那契数
```cpp
#include <iostream>
#include <string>
using namespace std;

string add(const string &a, const string &b) {
    string s = a.size() < b.size() ? a : b;
    const string &t = a.size() < b.size() ? b : a;
    s = string(t.size() - s.size(), '0') + s;

    int carry = 0, n = t.size();
    for(int i = n - 1; i >= 0; --i) {
        int temp = s[i] - '0' + t[i] - '0' + carry;
        s[i] = temp % 10 + '0';
        carry = temp / 10;
    }
    return carry ? "1" + s : s;
}

int main() {
    string f1 = "1", f2 = "1", temp;
    int cnt = 2;
    while(f2.size() < 1000) {
        ++cnt;
        temp = f2;
        f2 = add(f1, f2);
        f1 = temp;
    }
    cout << cnt << endl;

    return 0;
}
```

### 1.6 大整数乘法
原理：
- 一个 m 位数乘以一个 n 位数，它们乘积的位数不会超过 m + n;
- 第一个数的第 i 位和第二个数的第 j 位，相乘的结果应放在积的第 i + j + 1 位；
```cpp
string multiple(const string &a, const string &b) {
    int m = a.size(), n = b.size();
    string res(m + n, '0');

    for(int i = m - 1; i >= 0; --i) {
        int carry = 0;
        int p = a[i] - '0';
        for(int j = n - 1; i >= 0; --j) {
            int r = b[j] - '0';
            int temp = res[i + j + 1] - '0' + p * r + carry;
            res[i + j + 1] = temp % 10 + '0';
            carry = temp / 10;
        }
        res[i] = carry + '0';
    }
    int idx = res.find_first_not_of('0');
    return idx == -1 ? "0" : res.substr(idx);
}
```

### 1.7 大整数除法
```cpp
#include <iostream>
#include <string>
using namespace std;

int comp(const string &a, const string &b) {
    if(a == b) return 0;
    if(a.size() < b.size() || (a.size() == b.size() && a < b)) return -1;
    return 1;
}

//comp(a, b) != -1
void subtract(string &a, const string &b) {
    int n = a.size(), m = b.size();
    int carry = 0;
    for(int i = n - 1, j = m - 1; j >= 0; --i, --j) {
        int temp = (a[i] - '0') + carry - (b[j] - '0');
        a[i] = (temp + 10) % 10 + '0';
        carry = temp < 0 ? -1 : 0;
    }
    if(carry == -1) --a[0];
    int idx = a.find_first_not_of('0');
    a = idx == -1 ? "" : a.substr(idx);
}


//comp(a, b != -1)
void simulate(const string &a, const string &b, string &rem, string &quo) {
    int n = a.size(), m = b.size();
    for(int i = 0; i < n; ++i) {
        rem += a[i];
        //若没有, 10000 / 1 会出现bug
        if(rem == "0") rem = "";
        char temp = '0';
        while(comp(rem, b) != -1) {
            subtract(rem, b);
            ++temp;
        }
        quo += temp;
    }
    int idx = quo.find_first_not_of('0');
    quo = quo.substr(idx);

    idx = rem.find_first_not_of('0');
    rem = idx == -1 ? "0" : rem.substr(idx);
}

string divide(const string &a, const string &b) {
    if(comp(a, b) == -1) return "0";
    string rem, quo;
    simulate(a, b, rem, quo);
    return quo;
}

string mod(const string &a, const string &b) {
    if(comp(a, b) == -1) return a;
    string rem, quo;
    simulate(a, b, rem, quo);
    return rem;
}

int main() {
    string a, b;
    while(cin >> a >> b) {
        if(b == "0") {
            cout << "divided by zero!" << endl;
            continue;
        }
        string quo = divide(a, b);
        cout << a << " / " << b << " = " << quo << endl;
        string rem = mod(a, b);
        cout << a << " % " << b << " = " << rem << endl;
    }
    return 0;
}
```

## 1.8 Euler 15. 栅格路径
两种思路：
- 动态规划：
- 数学思路：
```cpp
#include <iostream>
using namespace std;

int main() {
    long long ans = 1;
    //相当于依次计算c(40, 1), c(40, 2)，而这些一定是整数，所以不会发生除不尽的情况
    for(int i = 1, j = 40; j > 20; ++i, --j) {
        ans *= j;
        ans /= i;
    }
    cout << ans << endl;
    return 0;
}
```
### 1.9 Euler 18. 最大和路径
数字三角形（数塔问题）
- 从上往下；
- 从下往上；
```cpp
//从上往下
#include <iostream>
using namespace std;

int main() {
    const int n = 15;
    int nums[n][n];
    for(int i = 0; i < n; ++i) {
        for(int j = 0; j <= i; ++j) {
            cin >> nums[i][j];
        }
    }
    int dp[n] = {0};
    dp[0] = nums[0][0];
    for(int i = 1; i < n; ++i) {
        for(int j = i; j > 0; --j) {
            dp[j] = max(dp[j], dp[j - 1]) + nums[i][j];
        }
        dp[0] += nums[i][0];
    }

    int ans = dp[0];
    for(int i = 1; i < n; ++i) {
        ans = max(ans, dp[i]);
    }
    cout << ans << endl;

    return 0;
}

//从下往上
#include <iostream>
using namespace std;

int main() {
    const int n = 15;
    int nums[n][n];
    for(int i = 0; i < n; ++i) {
        for(int j = 0; j <= i; ++j) {
            cin >> nums[i][j];
        }
    }
    int dp[n + 1] = {0};
    for(int i = n - 1; i >= 0; --i) {
        for(int j = 0; j <= i; ++j) {
            dp[j] = nums[i][j] + max(dp[j], dp[j + 1]);
        }
    }
    cout << dp[0] << endl;
    return 0;
}
```
### 1.10 海贼OJ 590. 数塔狂想曲

### 1.11 Euler 22. 姓名得分
注意点：
- 如何预处理数据：“:%s/","/ /g”;
- C++如何循环读入；


```cpp
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

int main() {
    int n = 0;
    string name[6000];
    while(cin >> name[n]) {
        ++n;
    }
    sort(name, name + n);
    long long ans = 0;
    for(int i = 0; i < n; ++i) {
        int t = 0;
        for(int j = 0; j < name[i].size(); ++j) {
            t += name[i][j] - 'A' + 1;
        }
        ans += t * (i + 1);
    }
    cout << ans << endl;
    return 0;
}
```

### 1.12 Euler 32. 全数字的乘积
思考：
- 被乘数，乘数，乘积组成9位数字；
- 为了避免重复，被乘数作为较小数：最小为 1， 最大为100；
- 较小数，较大数，乘积的总位数打于9，则不再继续循环；
- digit(a) + digit(b) >= digit(a * b);

```cpp
#include <iostream>
using namespace std;

int digit(int x) {
    int cnt = 0;
    while(x) {
        x /= 10;
        ++cnt;
    }
    return max(1, cnt);
}

int func(int x, int *num) {
    while(x) {
        if(num[x % 10]) return 0;
        num[x % 10] = 1;
        x /= 10;
    }
    return 1;
}

int check(int x, int y, int z) {
    int num[10] = {0};
    num[0] = 1;
    if(func(x, num) == 0) return 0;
    if(func(y, num) == 0) return 0;
    if(func(z, num) == 0) return 0;
    return 1;
}

int main() {
    int ans = 0, visited[10000] = {0};
    for(int i = 1; i < 100; ++i) {
        for(int j = i + 1; 1; ++j) {
            int temp = i * j;
            int cnt = digit(i) + digit(j) + digit(temp);
            if(cnt > 9) break;
            if(cnt == 9 && check(i, j, temp) && !visited[temp]) {
                cout << i << " * " << j << " = " << temp << endl;
                ans += temp;
                visited[temp] = 1;
            }
        }
    }
    cout << ans << endl;

    return 0;
}
```

### 1.13 Euler 33. 消去数字的分数
关键词：
- 十字相乘法；


```cpp
#include <iostream>
using namespace std;

bool check(int a, int b) {
    int x1 = a / 10, x2 = a % 10;
    int y1 = b / 10, y2 = b % 10;
    if(!x1 || !x2 || !y1 || !y2) return 0;
    if(x1 == y1 && y2 * a == x2 * b) return true;
    if(x1 == y2 && x2 * b == y1 * a) return true;
    if(x2 == y1 && x1 * b == y2 * a) return true;
    if(x2 == y2 && x1 * b == y1 * a) return true;
    return 0;
}

int gcd(int a, int b) {
    while(b) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

int main() {
    int a = 1, b = 1;
    for(int i = 11; i < 100; ++i) {
        for(int j = i + 1; j < 100; ++j) {
            if(check(i, j)) {
                a *= i;
                b *= j;
                cout << i << "/" << j << endl;
            }
        }
    }
    int c = gcd(a, b);
    cout << b / c << endl;
    return 0;
}
```
### 1.14 Euler 36. 双进制回文数
```cpp
#include <iostream>
using namespace std;

bool is_palindromes(int x, int base) {
    int y = 0, z = x;
    while(x) {
        y = y * base + x % base;
        x /= base;
    }
    return y == z;
}

int main() {
    int res = 0;
    for(int i = 1; i < 1000000; ++i) {
        if(is_palindromes(i, 10) && is_palindromes(i, 2)) {
            res += i;
            cout << i << endl;
        }
    }
    cout << res << endl;

    return 0;
}
```

### 1.15 Euler 30. 各位数字的五次幂
关键词：
- 上界估计；


```cpp
#include <iostream>
using namespace std;

int num[10];
void init() {
    for(int i = 1; i < 10; ++i) {
        int t = i;
        for(int j = 0; j < 4; ++j) {
            t *= i;
        }
        num[i] = t;
    }
}

bool check(int x) {
    int y = x;
    int temp = 0;
    while(x) {
        temp += num[x % 10];
        x /= 10;
    }
    return y == temp;
}

int main() {
    init();
    int ans = 0;
    for(int i = 10; i < 1000000; ++i) {
        if(check(i)) {
            ans += i;
            cout << i << endl;
        }
    }
    cout << ans << endl;

    return 0;
}

```
### 1.16 Euler 34. 各位数字的阶乘

```cpp
#include <iostream>
using namespace std;

int num[10];

void init() {
    num[0] = 1;
    for(int i = 1; i < 10; ++i) {
        num[i] = i * num[i - 1];
    }
}

bool check(int x) {
    int y = 0, z = x;
    while(x) {
        y += num[x % 10];
        x /= 10;
    }
    return y == z;
}

int main() {
    int ans = 0;
    init();
    for(int i = 3; i < 10000000; ++i) {
        if(check(i)) {
            ans += i;
            cout << i << endl;
        }
    }
    cout << ans << endl;

    return 0;
}

```

## 2 二分专题

### 2.1 海贼OJ 380. 大统领投票
```cpp
#include <iostream>
#include <string>
#include <algorithm>
#include <vector>
using namespace std;

int main() {
    int n = 0;
    cin >> n;
    vector<pair<string, int>> ps;
    string s;
    for(int i = 0; i < n; ++i) {
        cin >> s;
        ps.push_back({s, i + 1});
    }
    sort(ps.begin(), ps.end(), [](const pair<string, int> &a, const pair<string, int> &b) {
        if(a.first.size() == b.first.size()) {
            return a.first > b.first;
        }
        return a.first.size() > b.first.size();
    });
    cout << ps[0].second << endl;
    cout << ps[0].first << endl;

    return 0;
}
```

### 2.2 海贼OJ 381. 谁拿了最多的奖学金
```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    string winner;
    int mx = 0, sum = 0;
    int n = 0;
    cin >> n;
    string name;
    int ts, cs, paper;
    char b, w;
    for(int i = 0; i < n; ++i) {
        cin >> name >> ts >> cs >> b >> w >> paper;
        int temp = 0;
        if(ts > 80 && paper > 0) {
            temp += 8000;
        }
        if(ts > 85 && cs > 80) {
            temp += 4000;
        }
        if(ts > 90) {
            temp += 2000;
        }
        if(ts > 85 && w == 'Y') {
            temp += 1000;
        }
        if(cs > 80 && b == 'Y') {
            temp += 850;
        }
        if(temp > mx) {
            winner = name;
            mx = temp;
        }
        sum += temp;
    }
    cout << winner << endl;
    cout << mx << endl;
    cout << sum << endl;

    return 0;
}
```

### 2.3 海贼OJ 386. 吃瓜群众
分类：
- 朴素二分；
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int binary_search(const vector<pair<int, int>> &nums, int x) {
    int n = nums.size();
    int p = 0, r = n - 1;
    while(p <= r) {
        int q = p + r >> 1;
        if(nums[q].first == x) return nums[q].second;
        nums[q].first < x ? p = q + 1 : r = q - 1;
    }
    return 0;
}

int main() {
    int m = 0, n = 0;
    cin >> m >> n;
    vector<pair<int, int>> nums(m);
    for(int i = 0; i < m; ++i) {
        int x = 0;
        cin >> x;
        nums[i] = {x, i + 1};
    }
    sort(nums.begin(), nums.end());

    for(int i = 0; i < n; ++i) {
        int x = 0;
        cin >> x;
        cout << binary_search(nums, x) << endl;
    }

    return 0;
}
```
### 2.4 海贼OJ 387. 吃瓜群众升级版
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int binary_search01(const vector<pair<int, int>> &nums, int x) {
    //虚拟尾指针
    int p = 0, r = nums.size();
    while(p < r) {
        int q = p + r >> 1;
        nums[q].first < x ? p = q + 1 : r = q;
    }
    return p == nums.size() ? 0 : nums[p].second;
}

int main() {
    int m = 0, n = 0;
    cin >> m >> n;
    vector<pair<int, int>> nums(m);
    for(int i = 0; i < m; ++i) {
        int x = 0;
        cin >> x;
        nums[i] = {x, i + 1};
    }
    sort(nums.begin(), nums.end());
    for(int i = 0; i < n; ++i) {
        int x = 0;
        cin >> x;
        cout << binary_search01(nums, x) << endl;
    }

    return 0;
}
```

### 2.5 LeetCode 278. 第一个错误版本
```cpp
int firstBadVersion(int n) {
    unsigned int p = 1, r = n + 1;
    while(p < r) {
        unsigned int q = p + r >> 1;
        isBadVersion(q) ? r = q : p = q + 1;
    }
    return p;
}
```

### 2.6 海贼OJ 390. 原木切割
问题：
- 二分最优化，确定上下界；
- 11110000
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

bool check(const vector<int> &nums, int x, int n) {
    for(int i = 0; i < nums.size(); ++i) {
        n -= nums[i] / x;
    }
    return n <= 0;
}

int main() {
    int n = 0, m = 0;
    cin >> n >> m;
    vector<int> nums(n);
    int p = 0, r = 0;
    for(int i = 0; i < n; ++i) {
        cin >> nums[i];
        r = max(r, nums[i]);
    }
    while(p < r) {
        int q = p + r + 1 >> 1;
        check(nums, q, m) ? p = q : r = q - 1;
    }
    cout << p << endl;
    return 0;
}
```

### 2.7 海贼OJ 389. 暴躁的程序猿
分析：
- 类型：11110000
- 虚拟下界：0；
- 上界：最大工位；
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

bool check(const vector<int> &nums, int x, int n) {
    int pre = 0;
    --n;
    for(int i = 1; i < nums.size(); ++i) {
        if(nums[i] - nums[pre] < x) continue;
        pre = i;
        --n;
    }
    return n <= 0;
}

int main() {
    int m = 0, n = 0;
    cin >> m >> n;
    vector<int> nums(m);
    int p = 0, r = 0;
    for(int i = 0; i < m; ++i) {
        cin >> nums[i];
        r = max(r, nums[i]);
    }
    sort(nums.begin(), nums.end());
    while(p < r) {
        int q = p + r + 1 >> 1;
        check(nums, q, n) ? p = q : r = q - 1;
    }
    cout << p << endl;
    return 0;
}
```
### 2.8 海贼OJ 393. 切绳子
分析：
- 类型：11110000，浮点二分；
- 虚拟上界：0；
- 下界：最长绳子；

```cpp
#include <iostream>
#include <vector>
#include <iomanip>
using namespace std;

bool check(const vector<double> &nums, double x, int n) {
    for(int i = 0; i < nums.size(); ++i) {
        n -= (int)(nums[i] / x);
    }
    return n <= 0;
}

int main() {
    int n = 0, k = 0;
    cin >> n >> k;
    vector<double> nums(n);
    double p = 0, r = 0;
    for(int i = 0; i < n; ++i) {
        cin >> nums[i];
        r = max(r, nums[i]);
    }
    while(r - p > 0.00001) {
        double q = (p + r) / 2;
        check(nums, q, k) ? p = q : r = q;
    }
    cout << fixed << setprecision(2);
    //需要注意下
    cout << (int)(p * 100) / 100.0 << endl;
    return 0;
}
```

### 2.9 海贼OJ 82.伐木
分析：
- 类型：11110000；
- 虚拟下界：-1；
- 上界：最高的树；
```cpp
#include <iostream>
#include <vector>
using namespace std;
bool check(const vector<int> &nums, int x, long long n) {
    for(int i = 0; i < nums.size(); ++i) {
        n -= max(0, nums[i] - x);
    }
    return n <= 0;
}
int main() {
    int n = 0, m = 0;
    cin >> n >> m;
    vector<int> nums(n);
    int p = 0, r = 0;
    for(int i = 0; i < n; ++i) {
        cin >> nums[i];
        r = max(r, nums[i]);
    }
    while(p < r) {
        int q = p + r + 1 >> 1;
        check(nums, q, m) ? p = q : r = q - 1;
    }
    cout << p << endl;
    return 0;
}
```

### 2.10 海贼OJ 391. 数列分段
分析：
- 类型：00001111；
- 下界：最小值；
- 上界：所有数的和；
```cpp
#include <iostream>
#include <vector>
using namespace std;

bool check(const vector<int> &nums, long long x, int n) {
    long long cur = 0;
    for(int i = 0; i < nums.size(); ++i) {
        cur += nums[i];
        if(cur <= x) continue;
        cur = nums[i];
        --n;
    }
    return n > 0;
}

int main() {
    int n = 0, m = 0;
    cin >> n >> m;
    vector<int> nums(n);
    long long p = nums[0], r = 0;
    for(int i = 0; i < n; ++i) {
        cin >> nums[i];
        p = min(p, nums[i]);
        r += nums[i];
    }
    while(p < r) {
        long long q = p + r >> 1;
        check(nums, q, m) ? r = q : p = q + 1;
    }
    cout << p << endl;
    return 0;
}
```

### 2.11 海贼OJ 394. 跳石头
分析：
- 类型：11110000；
- 下界：0；
- 上界：起点到中点的距离；
```cpp
#include <iostream>
#include <vector>
using namespace std;

bool check(const vector<int> &nums, int x, int n) {
    int pre = 0;
    for(int i = 1; i < nums.size(); ++i) {
        if(nums[i] - nums[pre] < x) {
            --n;
        } else {
            pre = i;
        }
    }
    return n >= 0;
}

int main() {
    int l = 0, n = 0, m = 0;
    cin >> l >> n >> m;
    vector<int> nums(n + 2);
    nums[0] = 0;
    for(int i = 1; i <= n; ++i) {
        cin >> nums[i];
    }
    nums[n + 1] = l;
    int p = 0, r = l;
    while(p < r) {
        int q = p + r + 1 >> 1;
        check(nums, q, m) ? p = q : r = q - 1;
    }
    cout << p << endl;
    return 0;
}
```

### 2.12 海贼OJ 392. 丢瓶盖
分析：
- 类型：11110000；
- 下界；0；
- 上界：最远两个瓶盖的距离；

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

bool check(const vector<int> &nums, int x, int n) {
    int pre = 0;
    for(int i = 1; i < nums.size(); ++i) {
        if(nums[i] - nums[pre] < x) {
            --n;
        } else {
            pre = i;
        }
    }
    return n >= 0;
}

int main() {
    int a = 0, b = 0;
    cin >> a >> b;
    vector<int> nums(a);
    for(int i = 0; i < a; ++i) {
        cin >> nums[i];
    }
    sort(nums.begin(), nums.end());
    int p = 0, r = nums.back() - nums.front();
    while(p < r) {
        int q = p + r + 1 >> 1;
        check(nums, q, a - b) ? p = q : r = q - 1;
    }
    cout << p << endl;
    return 0;
}
```

### 2.13 海贼OJ 395. 复制书稿
分析：
- 类型：00001111
- 下界：0；
- 上界：所有书都给一个人抄写；

```cpp
#include <iostream>
#include <vector>
using namespace std;

bool check(const vector<int> &nums, int x, int n) {
    int cur = 0;
    for(int i = 0; i < nums.size(); ++i) {
        cur += nums[i];
        if(cur <= x) continue;
        --n;
        cur = nums[i];
    }
    return n > 0;
}

int main() {
    int m = 0, k = 0;
    cin >> m >> k;
    vector<int> nums(m);
    int p = 0, r = 0;
    for(int i = 0; i < m; ++i) {
        cin >> nums[i];
        r += nums[i];
    }
    while(p < r) {
        int q = p + r >> 1;
        check(nums, q, k) ? r = q : p = q + 1;
    }
    int n = nums.size();
    int cur = 0;
    vector<int> task(k + 1, 0);
    task[k] = m;

    for(int i = n - 1, j = k; i >= 0; --i) {
        cur += nums[i];
        if(cur <= p) continue;
        task[--j] = i + 1;
		cur = nums[i];
    }
    for(int i = 1; i < task.size(); ++i) {
        cout << task[i - 1] + 1 << " ";
        cout << task[i] << endl;
    }
    return 0;
}
```

## 3 海贼OJ题目（半个排序专题）
### 3.1 599. 两数之和（排序）
扩展：
- 三数之和；


```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n = 0, t = 0;
    cin >> n >> t;
    vector<int> nums(n);
    for(int i = 0; i < n; ++i) {
        cin >> nums[i];
    }
    for(int i = 0, j = n - 1; i < j;) {
        int temp = nums[i] + nums[j];
        if(temp == t) {
            cout << i << " " << j << endl;
            return 0;
        }
        temp < t ? ++i : --j;
    }
    
    return 0;
}
```

### 3.2 600. 杨氏矩阵（排序）
思路：
- 从左下角或右上角出发；

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n = 0, m = 0;
    cin >> n >> m;
    vector<vector<int>> mat(n, vector<int>(m));
    for(int i = 0; i < n; ++i) {
        for(int j = 0; j < m; ++j) {
            cin >> mat[i][j];
        }
    }
    int t = 0;
    cin >> t;
    for(int i = 0, j = m - 1; i < n && j >= 0;) {
        if(mat[i][j] == t) {
            cout << i + 1 << " " << j + 1 << endl;
            return 0;
        }
        mat[i][j] < t ? ++i : --j;
    }
    return 0;
}
```

### 3.3 477. 元音字母
骚操作：
- 字符串 '\0' 秒用；

```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    int mx = 0, pre = -1;
    string s;
    cin >> s;
    for(int i = 0; s[i]; ++i) {
        if(s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {
            if(pre != -1) {
                mx = max(mx, i - pre);
            }
            pre = i;
        }
    }
    cout << mx << endl;
    return 0;
}
```
### 3.4 479. 乒乓球
```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    string s;
    vector<pair<int, int>> res11, res21;
	int x11 = 0, y11 = 0, x21 = 0, y21 = 0;
    while(cin >> s) {
        for(int i = 0; i < s.size(); ++i) {
            if(s[i] == 'E') {
                res11.push_back({x11, y11});
                res21.push_back({x21, y21});
                for(int j = 0; j < res11.size(); ++j) {
                    cout << res11[j].first << ":" << res11[j].second << endl;
                }
				cout << endl;
                for(int j = 0; j < res21.size(); ++j) {
                    cout << res21[j].first << ":" << res21[j].second << endl;
                }
                return 0;
            }
            if(s[i] == 'W') {
                ++x11;
                ++x21;
            } else {
                ++y11;
                ++y21;
            }
            if((x11 >= 11 || y11 >= 11) && abs(x11 - y11) > 1) {
                res11.push_back({x11, y11});
                x11 = 0;
                y11 = 0;
            }
            if((x21 >= 21 || y21 >= 21) && abs(x21 - y21) > 1) {
                res21.push_back({x21, y21});
                x21 = 0;
                y21 = 0;
            }
        }
    }

    return 0;
}
```

### 3.5 480. 保龄球
```cpp
#include <cstdio>

int main() {
	char s[25] = {0};
	scanf("%[^\n]", s);
	int nums[25];
	for(int i = 0, idx = 0; s[i]; ++i) {
	    if(s[i] == ' ') continue;
		if(s[i] == '/') {
			nums[idx++] =  i == 0 || s[i - 1] == ' ' ? 10 : 10 - nums[idx - 2];
		} else {
		    nums[idx++] = (s[i] - '0');
		}
	}
	
	int res = 0;
	for(int i = 0, cnt = 0; cnt < 10; ++i) {
	    int temp = nums[i] + nums[i + 1];
		if(nums[i] == 10) {
		    temp += nums[i + 2];
		} else {
			temp == 10 && (temp += nums[i + 2]);
			++i;
		}
		res += temp;
		++cnt;
	}
	
	printf("%d\n", res);
    return 0;
}
```

### 3.6 481. 冰壶比赛
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    int r = 0;
    cin >> r;
    int x = 0, y = 0;
    for(int i = 0; i < 10; ++i) {
        vector<int> nums_x(8, 0);
        for(int j = 0; j < 8; ++j) {
            cin >> nums_x[j];
        }
        vector<int> nums_y(8, 0);
        for(int j = 0; j < 8; ++j) {
            cin >> nums_y[j];
        }
        if(nums_x[0] == -1) break;
        sort(nums_x.begin(), nums_x.end());
        sort(nums_y.begin(), nums_y.end());

        int temp_x = 0, temp_y = 0;
        if(nums_x[0] < nums_y[0]) {
            for(int j = 0; j < 8; ++j) {
                if(nums_x[j] > r || nums_x[j] >= nums_y[0]) break;
                ++temp_x;
            }
        } else {
            for(int j = 0; j < 8; ++j) {
                if(nums_y[j] > r || nums_y[j] >= nums_x[0]) break;
                ++temp_y;
            }
        }
        cout << temp_x << ":" << temp_y << endl;
        x += temp_x;
        y += temp_y;
    }
    cout << x << ":" << y << endl;
    
    return 0;
}
```

### 3.7 484. 柱状统计图
```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    int cnt[26] = {0};
    string s;
    int mx = 0;
    while(cin >> s) {
        for(int i = 0; i < s.size(); ++i) {
            if(!isupper(s[i])) continue;
            ++cnt[s[i] - 'A'];
            mx = max(mx, cnt[s[i] - 'A']);
        }
    }
    for(int i = mx; i > 0; --i) {
        int k = -1;
        for(int j = 25; j >= 0; --j) {
            if(cnt[j] >= i) {
                k = j;
                break;
            }
        }
        for(int j = 0; j < k; ++j) {
            if(j) cout << " ";
            if(cnt[j] >= i) {
                cout << "*";
            } else {
                cout <<" ";
            }
        }
        cout << endl;
    }
    for(int i = 0; i < 26; ++i) {
        if(i) cout << " ";
        cout << ('A' + i);
    }
    cout << endl;

    return 0;
}
```

### 3.8 485. 均分纸牌
- 如果当前堆多于平均
  - 前面堆也多于平均，那只能往后移动；
  - 前面小于平均，先往前面移，再往后面移； 
```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int n = 0, sum = 0;
    cin >> n;
    vector<int> nums(n);
    for(int i = 0; i < n; ++i) {
        cin >> nums[i];
        sum += nums[i];
    }
    int avg = sum / n;
    int res = 0;
    for(int i = 0; i < n - 1; ++i) {
        if(nums[i] == avg) continue;
        ++res;
        num[i + 1] += nums[i] - avg;
        nums[i] = avg;
    }
    cout << res << endl;
    return 0;
}
```
### 3.9 503. 独木舟（排序）
注意点：
- 排序，然后双指针，考虑到数据，可以使用桶排序；
- 双指针有个坑：理论上是要选择排序后满足条件的最后一个数（贪心），但实际上选满足条件的第一个数就可以了。

```cpp
#include <cstdio>

int main() {
    int w = 0, n = 0;
    scanf("%d%d", &w, &n);
    int cnt[201] = {0}, nums[30001];
    for(int i = 0; i < n; ++i) {
        int x = 0;
        scanf("%d", &x);
        ++cnt[x];
    }
    for(int i = 5, k = 0; i < 201; ++i) {
        for(int j = 0; j < cnt[i]; ++j) {
            nums[k++] = i;
        }
    }
    int res = 0;
    for(int i = 0, j = n - 1; i <= j; --j) {
        nums[i] + nums[j] > w || ++i;
        ++res;
    }
    printf("%d\n", res);
    return 0;
}
```

### 3.10 504. 删数
思路：
- 加一个digit之前，需要把前面比它大的digit全部删除；
- 如果没有删够，剩余的从末尾删除；
```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    string s, t;
    int n;
    cin >> s >> n;
    for(int i = 0; i < s.size(); ++i) {
        while(!t.empty() && n > 0 && t.back() > s[i]) {
            t.pop_back();
            --n;
        }
        t += s[i];
    }
	while(n--) t.pop_back();
    int idx = t.find_first_not_of('0');
    cout << (idx == -1 ? "0" : t.substr(idx)) << endl;
    return 0;
}
```
### 3.11 505. 最大整数（排序）
```cpp
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    int n = 0;
    cin >> n;
    vector<string> ss(n);
    for(int i = 0; i < n; ++i) {
        cin >> ss[i];
    }
    sort(ss.begin(), ss.end(), [](const string &a, const string &b){
        return a + b > b + a;
    });
    for(int i = 0; i < n; ++i) {
        cout << ss[i];
    }
    cout << endl;
    return 0;
}
```

### 3.12 508 两人过河（排序）

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    int n = 0;
    cin >> n;
    vector<int> nums(n);
    for(int i = 0; i < n; ++i) {
        cin >> nums[i];
    }
    if(n == 1) return nums[0];

    sort(nums.begin(), nums.end());
    int res = 0;
    for(int i = n - 1; i > 0; i -= 2) {
        if(i == 1) {
            res += nums[1];
        } else if(i == 2) {
            res += nums[0] + nums[1] + nums[2];
        } else {
            res += min(nums[0] + nums[i] + nums[0] + nums[i - 1],
                       nums[1] + nums[0] + nums[i] + nums[1]);
        }
    }
    cout << res << endl;
    return 0;
}
```
### 3.13 509. 智力大冲浪（排序）
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

/*int main() {
    int m = 0, n = 0;
    cin >> m >> n;
    vector<pair<int, int>> nums(n);
    for(int i = 0; i < n; ++i) {
        cin >> nums[i].second;
    }
    for(int i = 0; i < n; ++i) {
        cin >> nums[i].first;
    }
    sort(nums.begin(), nums.end(), [](auto a, auto b) {
        if(a.first == b.first) retuurn a.second < b.second;
        return a.first > b.first;
    });
    for(int i = 0; i < n; ++i) {
        if(nums[i].second < i + 1) {
            w -= nums[i].first;
        }
    }
    cout << w << endl;
    return 0;
}*/
```

### 3.14 518. 金币
```cpp
#include <iostream>
using namespace std;

int main() {
    int x = 0;
    cin >> x;
    int res = 0;
    for(int i = 0, j = 1, k = 1; i < x; ++i, --k) {
        if(k == 0) ++j, k = j;
        res += j;
    }
    cout << res << endl;
    return 0;
}
```

### 3.15 513. 楼层编号

```cpp
#include <iostream>
using namespace std;

int main() {
    int m = 0, t = 0;
    cin >> m >> t;
    int cnt = 0;
    for(int i = 1; i <= m; ++i) {
        int x = i;
        while(x) {
            if(x % 10 == t) break;
            x /= 10;
        }
        cnt += x == 0;
    }
    cout << cnt << endl;
    return 0;
}
```

### 3.16 514. 火柴棒等式（暴力）

```cpp
#include <iostream>
using namespace std;

int a[10] = {6,2,5,5,4,5,6,3,7,6};

int cnt(int x) {
    if(x == 0) return a[0];
    int res = 0;
    while(x) {
        res += a[x % 10];
        x /= 10;
    }
    return res;
}

bool check(int x, int y, int t) {
    int z = x + y;
    int xn = cnt(x), yn = cnt(y), zn = cnt(z);
    return cnt(x) + cnt(y) + cnt(z) + 4 == t;
}

int main() {
    int n = 0;
    cin >> n;
    int res = 0;
    for(int i = 1; i < 1000; ++i) {
        for(int j = 1; j < 1000; ++j) {
            res += check(i, j, n);
        }
    }
    cout << res << endl;
    return 0;
}
```

### 3.17 515. 

### 3.18 516. 奶牛碑文（prefix/suffix array）
```cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;

int main() {
    int n = 0;
    cin >> n;
    string s;
    cin >> s;
    long long res = 0;
    vector<long long> prefix(n, 0);
    for(int i = 0, j = 0; i < n; ++i) {
        prefix[i] = j;
        j += s[i] == 'C';
    }
    for(int i = n - 1, j = 0; i >= 0; --i) {
        if(s[i] == 'O') res += prefix[i] * j;
        j += s[i] == 'W';
    }
    cout << res << endl;

    return 0;
}
```

### 3.19 517. 三角形个数（brute force）
```cpp
#include <iostream>
using namespace std;

int main() {
    int n = 0;
    cin >> n;
    int cnt = 0;
    for(int i = 1; i <= n / 3; ++i) {
        int m = n - i;
        for(int j = i; j <= m / 2; ++j) {
            int k = m - j;
            cnt += (i + j > k);
        }
    }
    cout << cnt << endl;
    return 0;
}
```

### 3.20 519. 优雅数(枚举)
```cpp
#include <iostream>
using namespace std;

/*int main() {
    long long l = 0, r = 0;
    cin >> l >> r;
    int cnt = 0;
    for(int i = 0; i < 10; ++i) {
        for(int j = 0; j < 10; ++j) {
            if(i == j) continue;
            for(int k = 2; k < 18; ++i) {
                if(j == 0) {
                    ++cnt;
                    continue;
                }
            }
        }
    }
}*/

```

## 4 LeetCode题目讲解
### 4.1 前缀和
```cpp

```
### 4.2 LeetCode 13. 罗马数字转整数
```cpp
int romanToInt(string s) {
    int res = 0;
    for(int i = 0; i < s.size(); ++i) {
        switch(s[i]) {
            case 'V':
                res += 5;
                break;
            case 'L':
                res += 50;
                break;
            case 'D':
                res += 500;
                break;
            case 'M':
                res += 1000;
                break;

            case 'I':
                if(s[i + 1] == 'V' || s[i + 1] == 'X') {
                    res -= 1;
                } else {
                    res += 1;
                }
                break;
            case 'X':
                if(s[i + 1] == 'L' || s[i + 1] == 'C') {
                    res -= 10;
                } else {
                    res += 10;
                }
                break;
            case 'C':
                if(s[i + 1] == 'D' || s[i + 1] == 'M') {
                    res -= 100;
                } else {
                    res += 100;
                }
                break;
        }
    }
    return res;
}
```

### 4.3 LeetCode 14. 最长公共前缀

```cpp
string longestCommonPrefix(vector<string>& strs) {
    if(strs.empty()) return "";
    string s;
    for(int i = 0; i < strs[0].size(); ++i) {
        for(int j = 1; j < strs.size(); ++j) {
            if(strs[j][i] != strs[0][i]) return s;
        }
        s += strs[0][i];
    }
    return s;
}
```

### 4.4 LeetCode 26. 删除排序数组中的重复项
```cpp
int removeDuplicates(vector<int>& nums) {
    if(nums.empty()) return 0;
    int p = 1;
    for(int i = 1; i < nums.size(); ++i) {
        if(nums[i] != nums[i - 1]) {
            nums[p++] = nums[i];
        }
    }
    return p;
}
```
### 4.5 LeetCode 27. 删除元素
```cpp
int removeElement(vector<int>& nums, int val) {
    int p = 0;
    for(int i = 0; i < nums.size(); ++i) {
        if(nums[i] == val) continue;
        nums[p++] = nums[i];
    }
    return p;

}
```

### 4.6 LeetCode 35. 搜索插入位值
```cpp
int searchInsert(vector<int>& nums, int target) {
    int p = 0, r = nums.size();
    while(p < r) {
        int q = p + r >> 1;
        nums[q] < target ? p = q + 1 : r = q;
    }
    return p;
}
```


### 4.7 LeetCode 38. 外观数列
```cpp
string countAndSay(int n) {
    string s = "1";
    for(int i = 2; i <= n; ++i) {
        string temp;
        int cnt = 1;
        for(int j = 1; j <= s.size(); ++j) {
            if(s[j] == s[j - 1]) {
                ++cnt;
            } else {
                temp += to_string(cnt) + s[j - 1];
                cnt = 1;
            }
        }
        s = temp;
    }
    return s;     
}
```

### 4.8 LeetCode 53. 最大子序和（卡丹儿算法）
```cpp
int maxSubArray(vector<int>& nums) {
    int temp = nums[0], res = nums[0];
    for(int i = 1; i < nums.size(); ++i) {
        temp = max(nums[i], temp + nums[i]);
        res = max(temp, res);
    }
    return res;
}
```

### 4.9 LeetCode 66. 加一
```cpp
vector<int> plusOne(vector<int>& digits) {
    int n = digits.size();
    for(int i = n - 1; i >= 0; --i) {
        digits[i] += 1;
        if(digits[i] != 10) break;
        digits[i] = 0;
    }
    if(digits[0] == 0) digits.insert(digits.begin(), 1);
    return digits;
}
```
### 4.10 LeetCode 69. x的平方根
```cpp
int mySqrt(int x) {
    int p = 0, r = x / 2 + 1;
    while(p < r) {
        long long q = p + r + 1>> 1;
        q * q > x ? r = q - 1 : p = q;
    }        
    return p;
}
```
### 4.11 LeetCode 70. 爬楼梯（斐波那契数列）
```cpp
int climbStairs(int n) {
    int f1 = 1, f2 = 1;
    for(int i = 2; i <= n; ++i) {
        f2 += f1;
        f1 = f2 - f1;
    }
    return f2;
}
```

### 4.12 LeetCode 88. 合并两个有序数组
```cpp
void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
    int x = m + n - 1;
    --m; --n;
    while(m >= 0 && n >= 0) {
        nums1[x--] = nums1[m] < nums2[n] ? nums2[n--] : nums1[m--];
    }        
    while(n >= 0) {
        nums1[x--] = nums2[n--];
    }
}
```

### 4.13 LeetCode 118. 杨辉三角
```cpp
vector<vector<int>> generate(int n) {
    vector<vector<int>> res;
    for(int i = 0; i < n; ++i) {
        vector<int> temp(1, 1);
        for(int j = 1; j < i; ++j) {
            temp.push_back(res.back()[j - 1] + res.back()[j]);
        }
        if(i) temp.push_back(1);
        res.push_back(temp);
    }
    return res;  
}
```

### 4.14 LeetCode 121. 买卖股票的最佳时机I
```cpp
int maxProfit(vector<int>& prices) {
    if(prices.empty()) return 0;
    int res = 0;
    int mn = prices[0];
    for(int i = 1; i < prices.size(); ++i) {
        mn = min(prices[i], mn);
        res = max(res, prices[i] - mn);
    }
    return res;
}
```
### 4.15 LeetCode 122. 买卖股票的最佳时机II
```cpp
int maxProfit(vector<int>& prices) {
    int res = 0;
    for(int i = 1; i < prices.size(); ++i) {
        res += max(0, prices[i] - prices[i - 1]);
    }
    return res;
}
```

### 4.16 LeetCode 136. 只出现一次的数字
```cpp
int single(const vector<int> &nums) {
    int res = 0;
    for(int i = 0; i < nums.size(); ++i) {
        res ^= nums[i];
    }
    return res;
}
```

## 5 STL“容器”的使用与练习
### 5.1 queue与stack的操作
queue 和 stack 是 适配器 而不是 容器，其底层都是集于 deque（容器） 实现的；
### 5.2 vector 与 priority_queue
vector底层数组；
- 二维 vector<vector<int>>;
- greater<int>();

priority_queue:
- 底层实现是堆；
- 节点为自定义类型需要重载 operator< 运算符；
- greater<int>

### 5.3 string
- '\0' 妙用；

- substr
- find


### 5.4 map / set
底层实现 红黑树；

隐式消耗

### 5.5 unordered_map/unordered_set
底层实现 hash 表

### 5.6 海贼OJ 383. 周末舞会
```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    int x = 0, y = 0, n = 0;
    cin >> x >> y >> n;
    queue<int> man, woman;
    for(int i = 0; i < x; ++i) {
        man.push(i + 1);
    }
    for(int i = 0; i < y; ++i) {
        woman.push(i + 1);
    }
    for(int i = 0; i < n; ++i) {
        man.push(man.front());
        woman.push(woman.front());
        cout << man.front() << " " << woman.front() << endl;
        man.pop();
        woman.pop();
    }
    return 0;
}
```

### 5.7 海贼OJ 378. 字符串括号匹配2
```cpp
#include <iostream>
#include <stack>
#include <string>
using namespace std;

int main() {
    string s;
    cin >> s;
    stack<char> st;
    for(int i = 0; i < s.size(); ++i) {
        if(s[i] == '(' || s[i] == '[' || s[i] == '{') {
            st.push(s[i]);
        } else if(s[i] == ')') {
            if(!st.empty() && st.top() == '(') {
                st.pop();
            }
        } else if(s[i] == ']') {
            if(!st.empty() && st.top() == '[') {
                st.pop();
            }
        } else if(s[i] == '}') {
            if(!st.empty() && st.top() == '{') {
                st.pop();
            }
        }
    }
    if(st.empty()) {
        cout << "YES" << endl;
    } else {
        cout << "NO" << endl;
    }
    return 0;
}
```

### 5.8 海贼OJ 376. 机器翻译
```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    int m = 0, n = 0;
    cin >> m >> n;
    int flag[1001] = {0};
    queue<int> que;
    int res = 0;
    for(int i = 0; i < n; ++i) {
        int x = 0;
        cin >> x;
        if(flag[x]) continue;
        ++res;
        flag[x] = 1;

        if(que.size() == m) {
            flag[que.front()] = 0;
            que.pop();
        }
        que.push(x);
    }
    cout << res << endl;
    return 0;
}
```
### 5.9 海贼OJ 379. 仓库日志（最大栈）

两种思路：
- 第一种：最大栈和数据栈大小保持一致，始终push输入元素和最大栈栈顶的较大者；
- 第二种：保持最大栈严格单调递增，只有数据栈栈顶和最大栈栈顶元素相同时，最大栈才pop；
```cpp
#include <iostream>
#include <stack>
using namespace std;

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
    stack<int> s, mx;
    int n = 0;
    cin >> n;
    for(int i = 0; i < n; ++i) {
        int a = 0;
        cin >> a;
        if(a == 0) {
            cin >> a;
            s.push(a);
            if(mx.empty()) {
                mx.push(a);
            } else {
                mx.push(max(a, mx.top()));
            }
        } else if(a == 1) {
            if(!s.empty()) {
                mx.pop();
                s.pop();
            }
        } else {
            if(s.empty()) {
                cout << 0 << endl;
            } else {
                cout << mx.top() << endl;
            }
        }
    }
    return 0;
}
```

### 5.10 海贼OJ 382. 报数（约瑟夫环问题）
```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    int n = 0, m = 0;
    cin >> n >> m;
    queue<int> que;
    for(int i = 1; i <= n; ++i) {
        que.push(i);
    }
    int num = 1;
    while(que.size() > 1) {
        if(num == m) {
            num = 1;
        } else {
            que.push(que.front());
            ++num;
        }
        que.pop();
    }
    cout << que.front() << endl;

    return 0;
}
```

### 5.11 海贼OJ 384. 敲七

```cpp
#include <iostream>
#include <queue>
using namespace std;

bool check(int x) {
    if(x % 7 == 0) return true;
    while(x) {
        if(x % 10 == 7) return true;
        x /= 10;
    }
    return false;
}

int main() {
    int n = 0, x = 0, t = 0;
    cin >> n >> x >> t;
    queue<int> que;
    --x;
    for(int i = 0; i < n; ++i) {
        que.push((x + i) % n + 1);
    }
    while(que.size() > 1) {
        if(!check(t)) {
            que.push(que.front());
        }
        que.pop();
        ++t;
    }
    cout << que.front() << endl;
    return 0;
}
```

### 5.12 海贼OJ 385. 海港

### 5.13 海贼OJ 569. 溶液

### 5.14 LeetCode 232. 用栈实现队列
```cpp

```
### 5.15 LeetCode 225. 用队列实现栈
```cpp

```


## 6 排列组合与搜索走地图问题
此 “图” 非彼 “图”
### 6.1 海贼OJ 235. 递归实现指数型枚举（枚举）
思路：
- 从第一个数选，选还是不选两条路；
- 选第二个数，选还是不选两条路；
- ...
- 第 n 个数，选还是不选；
```cpp
#include <iostream>
#include <vector>
using namespace std;

void output(const vector<int> &nums) {
	for(int i = 0; i < nums.size(); ++i) {
	    if(i) cout << " ";
		cout << nums[i];
	}
	cout << endl;
}

void dfs(vector<int> &nums, int s, int n) {
	if(s > n) return;
	nums.push_back(s);
	output(nums);
	dfs(nums, s + 1, n);
	nums.pop_back();
	dfs(nums, s + 1, n);
}

int main() {
    int n = 0;
	cin >> n;
	vector<int> nums;
	dfs(nums, 1, n);
	
	return 0;
}
```
### 6.2 海贼OJ 236. 递归实现组合型枚举（排列组合枚举）
思路：
- 同上一题大致一样；
- 第一点不同是：输出时机略有变化（条件输出 而非 无条件输出）；
- 第二点不同是：递归结束条件略有变化（如果已经找到 m 个数了，也就没有再找下去的必要了）；
```cpp
#include <iostream>
#include <vector>
using namespace std;

void output(const vector<int> &nums) {
    for(int i = 0; i < nums.size(); ++i) {
        if(i) cout << " ";
        cout << nums[i];
    }
    cout << endl;
}

void dfs(vector<int> &nums, int s, int n, int m) {
    if(s > n || nums.size() == m) return;
    nums.push_back(s);
    if(nums.size() == m) {
        output(nums);
    }
    dfs(nums, s + 1, n, m);
    nums.pop_back();
    dfs(nums, s + 1, n, m);
}

int main() {
    int n = 0, m = 0;
    cin >> n >> m;
    vector<int> nums;
    dfs(nums, 1, n, m);

    return 0;
}
```

### 6.3 海贼OJ 236. 递归实现排列型枚举（排列组合枚举）
```cpp
#include <iostream>
#include <vector>
using namespace std;

void output(const vector<int> &nums) {
    for(int i = 0; i < nums.size(); ++i) {
        if(i) cout << " ";
        cout << nums[i];
    }
    cout << endl;
}

void dfs(vector<int> &nums, vector<bool> &visited, int n) {
    if(nums.size() == n) {
        output(nums);
        return;
    }
    int s = 0;
    for(int i = 1; i <= n; ++i) {
        if(visited[i]) continue;
        nums.push_back(i);
        visited[i] = true;
        dfs(nums, visited, n);

        nums.pop_back();
        visited[i] = false;
    }
    
}

int main() {
    int n = 0;
    cin >> n;
    vector<int> nums;
    vector<bool> visited(n + 1, false);
    dfs(nums, visited, n);
    return 0;
}
```

dfs/bfs都能解决连通性问题（从起点能否走到终点）
需要思考的问题：
- 如果存；
- 起点是什么？
- 终点是什么？
- 如何去重？（直接修改原数据，开标记数组）；

### 6.4 535.瓷砖（dfs）
```cpp
#include <iostream>
#include <vector>
using namespace std;

char mp[52][52];
int dir[4][2] = {-1, 0, 0, 1, 1, 0, 0, -1};
int ans = 0;

void dfs(int x, int y) {
    ++ans;
    for(int i = 0; i < 4; ++i) {
        int xx = x + dir[i][0];
        int yy = y + dir[i][1];
        if(mp[xx][yy] == '.') {
            mp[xx][yy] = '#';
            dfs(xx, yy);
        }
    }
}

int main() {
    int m = 0, n = 0;
    cin >> n >> m;
    int x = 0, y = 0;
    for(int i = 1; i <= m; ++i) {
        for(int j = 1; j <= n ++j) {
            cin >> mp[i][j];
            if(mp[i][j] == '@') {
                x = i; y = j;
            }
        }
    }
    dfs(x, y);
    cout << ans << endl;

    return 0;
}
```

### 6.5 海贼OJ 397. 僵尸来袭（dfs）
```cpp
#include <iostream>
using namespace std;

int mp[105][105];
int dir[4][2] = {-1, 0, 0, 1, 1, 0, 0, -1};

void dfs(int x, int y) {
    for(int i = 0; i < 4; ++i) {
        int xx = x + dir[i][0];
        int yy = y + dir[i][1];
        if(mp[xx][yy]) {
            mp[xx][yy] = 0;
            dfs(xx, yy);
        }
    }
}

int main() {
    int m = 0, n = 0;
    cin >> m >> n;
    for(int i = 1; i <= m; ++i) {
        for(int j = 1; j <= n; ++j) {
            cin >> mp[i][j];
        }
    }
    int ans = 0;
    for(int i = 1; i <= m; ++i) {
        for(int j = 1; j <= n; ++j) {
            if(mp[i][j]) {
                ++ans;
                dfs(i, j);
                mp[i][j] = 0;
            }
        }
    }
    cout << ans << endl;

    return 0;
}
```

### 6.6 海贼OJ 536.最大黑色区域（dfs）
```cpp
#include <iostream>
using namespace std;

int ans, temp;
char mp[105][105];
int dir[4][2] = {-1, 0, 0, 1, 1, 0, 0, -1};

void dfs(int x, int y) {
    ++temp;
    for(int i = 0; i < 4; ++i) {
        int xx = x + dir[i][0];
        int yy = y + dir[i][1];
        if(mp[xx][yy] == '1') {
            mp[xx][yy] = '0';
            dfs(xx, yy);
        }
    }
}

int main() {
    int m = 0, n = 0;
    cin >> m >> n;
    for(int i = 1; i <= m; ++i) {
        cin >> &mp[i][1];
    }

    for(int i = 1; i <= m; ++i) {
        for(int j = 1; j <= n; ++j) {
            if(mp[i][j] == '1') {
                temp = 0;
                mp[i][j] = '0';
                dfs(i, j);
                ans = max(temp, ans);
            }
        }
    }
    cout << ans << endl;

    return 0;
}
```

### 6.7 海贼OJ 396. 填图颜色（dfs）
外圈包一层零

需要进行边界判断
```cpp
#include <iostream>
using namespace std;

int n, mp[35][35];
int dir[4][2] = {-1, 0, 0, 1, 1, 0, 0, -1};

void dfs(int x, int y) {
    for(int i = 0; i < 4; ++i) {
        int xx = x + dir[i][0];
        int yy = y + dir[i][1];
        if(xx < 0 || yy < 0 || xx > n || yy > n || mp[xx][yy] != 0) continue;
        mp[xx][yy] = 3;
        dfs(xx, yy);
    }
}

int main() {
    cin >> n;
    for(int i = 1; i <= n; ++i) {
        for(int j = 1; j <= n; ++j) {
            cin >> mp[i][j];
        }
    }
    mp[0][0] = 3;
    dfs(0, 0);
    for(int i = 1; i <= n; ++i) {
        for(int j = 1; j <= n; ++j) {
            if(j != 1) cout << " ";
            if(mp[i][j] == 3) {
                cout << 0;
            } else if(mp[i][j] == 0) {
                cout << 2;
            } else {
                cout << mp[i][j];
            }
            cout << endl;
        }
    }
    return 0;
}
```

### 6.8 海贼OJ 404. 01迷宫简易版（dfs）
```cpp
#include <iostream>
using namespace std;

int m, n, ans;
char mp[3005][3005], visited[3005][3005];
int dir[4][2] = {-1, 0, 0, 1, 1, 0, 0, -1};

void dfs(int x, int y) {
    ++ans;
    for(int i = 0; i < 4; ++i) {
        int xx = x + dir[i][0];
        int yy = y + dir[i][1];
        if(xx <= 0 || yy <= 0 || xx > m || yy > n || mp[xx][yy] == mp[x][y] || visited[xx][yy]) continue;
        visited[xx][yy] = 1;
        dfs(xx, yy);
    }
}

int main() {
    cin >> m >> n;
    for(int i = 1; i <= m; ++i) {
        cin >> &mp[i][1];
    }
    int x = 0, y = 0;
    cin >> x >> y;

    visited[x][y] = 1;
    dfs(x, y);
    cout << ans << endl;

    return 0;
}
```

### 6.9 海贼OJ 405. 01迷宫简易版（dfs）
```cpp
#include <iostream>
#include <queue>
using namespace std;

int n, m, k, ans[3005][3005];
char mmap[3005][3005];
int dir[4][2] = {-1, 0, 0, 1, 1, 0, 0, -1};
int temp;
queue<pair<int, int>> que;

void dfs(int x, int y) {
    que.push({x, y});
    for(int i = 0; i < 4; ++i) {
        int xx = x + dir[i][0];
        int yy = y + dir[i][1];
        if(xx <= 0 || yy <= 0 || xx > m || yy > n || ans[xx][yy] || mmap[xx][yy] == mmap[x][y]) continue;
        ans[xx][yy] = 1;
        ++temp;
        
        dfs(xx, yy);
    }
}

void save() {
    while(!que.empty()) {
		int x = que.front().first, y = que.front().second;
        ans[x][y] = temp;
        que.pop();
    }
}

int main() {
    cin >> m >> n >> k;
    for(int i = 1; i <= m; ++i) {
        cin >> &mmap[i][1];
    }
    for(int i = 1; i <= m; ++i) {
        for(int j = 1; j <= n; ++j) {
            if(ans[i][j]) continue;
            temp = 1;
            ans[i][j] = 1;
            dfs(i, j);
            save();
        }
    }
    for(int i = 0; i < k; ++i) {
        int x = 0, y = 0;
        cin >> x >> y;
        cout << ans[x][y] << endl;
    }

    return 0;
}
```
<!-----------------------------bfs解决最小步数问题------------------------------->

### 6.10 海贼OJ 399. 小明吃饭
注意点：
- 最简单的bfs最小步数问题


```cpp
#include <iostream>
#include <queue>
using namespace std;


int m, n, ans;
int sx, sy, ex, ey;
char mmap[505][505];
int dir[4][2] = {-1, 0, 0, 1, 1, 0, 0, -1};

int main() {
    cin >> m >> n;
    
    for(int i = 1; i <= m; ++i) {
        for(int j = 1; j <= n; ++j) {
            cin >> mmap[i][j];
            if(mmap[i][j] == '2') {
                sx = i; sy = j;
            } else if(mmap[i][j] == '3') {
                ex = i; ey = j;
            }
        }
    }
    queue<pair<int, int>> que;
    que.push({sx, sy});
    mmap[sx][sy] = '#';
    int step = 0;
    while(!que.empty()) {
        int cnt = que.size();
        for(int i = 0; i < cnt; ++i) {
            int x = que.front().first;
            int y = que.front().second;
            que.pop();
            if(mmap[x][y] == '3') {
                cout << step << endl;
                return 0;
            }
            for(int j = 0; j < 4; ++j) {
                int xx = x + dir[j][0];
                int yy = y + dir[j][1];
                if(mmap[xx][yy] == '.') {
                    mmap[xx][yy] == '#';
                    que.push({xx, yy});
                }
            }
        }
        ++step;
    }
    cout << -1 << endl;
    return 0;
}
```

### 6.11 海贼OJ 304. 骑士风度的牛（bfs）
注意点：
- 不同的方向数组；
```cpp
#include <iostream>
#include <queue>
using namespace std;

int m, n, ans, sx, sy;
char mmap[155][155];
int dir[8][2]{-2, -1, -2, 1, -1, 2, 1, 2, 2, 1, 2, -1, 1, -2, -1, -2};

int main() {
    cin >> n >> m;
    for(int i = 2; i <= m; ++i) {
        for(int j = 2; j <= n; ++i) {
            cin >> mmap[i][j];
            if(mmap[i][j] == 'K') {
                sx = i; sy = j;
            }
        }
    }
    queue<pair<int, int>> que;
    que.push({sx, sy});
    mmap[sx][sy] = '*';
    int step = 1;
    while(!que.empty()) {
        int cnt = que.size();
        for(int i = 0; i < cnt; ++i) {
            int x = que.front().first;
            int y = que.front().second;
            que.pop();
            for(int j = 0; j < 8; ++j) {
                int xx = x + dir[j][0];
                int yy = y + dir[j][1];
                if(mmap[xx][yy] == 'H') {
                    cout << step << endl;
                    return 0;
                }
                if(mmap[xx][yy] == '.') {
                    mmap[xx][yy] = '*';
                    que.push({xx, yy});
                }
            }
            ++step;
        }
    }
    cout << -1 << endl;
    return 0;
}
```
### 6.12 海贼OJ 398.马的遍历（bfs）

注意点：
- memset妙用：每个字节都初始化为-1，则每个整数的初始化结果也是-1；
```cpp
#include <iostream>
#include <queue>
#include <cstring>
using namespace std;

int m, n, x, y;
int mmap[505][505];
int dir[8][2] = {-2, -1, -2, 1, -1, 2, 1, 2, 2, 1, 2, -1, 1, -2, -1, -2};

int main() {
    cin >> m >> n >> x >> y;
    memset(&mmap[0][0], -1, sizeof(mmap));
    queue<pair<int, int>> que;
    que.push({x, y});
    mmap[x][y] = 0;
    int step = 1;
    while(!que.empty()) {
        int cnt = que.size();
        for(int i = 0; i < cnt; ++i) {
            x = que.front().first;
            y = que.front().second;
			que.pop();
            for(int j = 0; j < 8; ++j) {
                int xx = x + dir[j][0];
                int yy = y + dir[j][1];
                if(xx < 1 || yy < 1 || xx > m || yy > n || mmap[xx][yy] != -1) continue;
                mmap[xx][yy] = step;
                que.push({xx, yy});
            }
        }
        ++step;
    }
    for(int i = 1; i <= m; ++i) {
        for(int j = 1; j <= n; ++j) {
            if(j > 1) cout << " ";
            cout << mmap[i][j];
        }
        cout << endl;
    }
    return 0;
}
```

### 6.13 海贼OJ 400. 奇怪的象棋游戏
混合方向数组
- 日 / 田

```cpp
#include <iostream>
#include <queue>
#include <cstring>
using namespace std;

int mmap[505][505];
int dir[12][2] = {-2, -1, -2, 1, -1, 2, 1, 2, 2, 1, 2, -1, 1, -2, -1, -2,
                  -2, -2, -2, 2, 2, 2, 2, -2};

int bfs(int x, int y) {
    memset(&mmap[0][0], 0, sizeof(mmap));

    queue<pair<int, int>> que;
    que.push({x, y});
    mmap[x][y] = 1;
    int step = 0;
    while(!que.empty()) {
        int cnt = que.size();
        for(int i = 0; i < cnt; ++i) {
            x = que.front().first;
            y = que.front().second;
            que.pop();
            if(x == 1 && y == 1) return step;
            for(int j = 0; j < 12; ++j) {
                int xx = x + dir[j][0];
                int yy = y + dir[j][1];
                if(xx < 1 || yy < 1 || xx > 500 || yy > 500 || mmap[xx][yy]) continue;
                mmap[xx][yy] = 1;
                que.push({xx, yy});
            }
        }
        ++step;
    }
    return -1;
}

int main() {
    int x1, y1, x2, y2;
    cin >> x1 >> y1 >> x2 >> y2;

    cout << bfs(x1, y1) << endl;
    cout << bfs(x2, y2) << endl;

    return 0;
}
```

### 6.14 海贼OJ 401. 奇怪的象棋游戏升级版

记录：

- 当起点和终点的距离一致时，也可以从终点向起点走；
- 有的时候从起点到终点和从终点到起点是不一样的，例如，马别腿的情况，这个时候就不能从终点到起点；

```cpp
#include <iostream>
#include <queue>
#include <cstring>
using namespace std;

int mmap[505][505];
int dir[12][2] = {-2, -1, -2, 1, -1, 2, 1, 2, 2, 1, 2, -1, 1, -2, -1, -2,
                  -2, -2, -2, 2, 2, 2, 2, -2};

int main() {
    int n = 0;
    cin >> n;

    memset(mmap, -1, sizeof(mmap));
    queue<pair<int, int>> que;
    que.push({1, 1});
    mmap[1][1] = 0;
    int step = 1;
    while(!que.empty()) {
        int cnt = que.size();
        for(int i = 0; i < cnt; ++i) {
            int x = que.front().first;
            int y = que.front().second;
            que.pop();
            for(int j = 0; j < 12; ++j) {
                int xx = x + dir[j][0];
                int yy = y + dir[j][1];
                if(xx < 1 || yy < 1 || xx > 500 || yy > 500 || mmap[xx][yy] != -1) continue;
                mmap[xx][yy] = step;
                que.push({xx, yy});
            }
        }
        ++step;
    }
    for(int i = 0; i < n; ++i) {
        int x = 0, y = 0;
        cin >> x >> y;
        cout << mmap[x][y] << endl;
    }

    return 0;
}

```

### 6.15 海贼OJ 303. 矩阵距离一（bfs，重点）

**多终点** 

- 把所有终点当作起点进行搜索（以所有终点为起点开始搜索，必须是终点到起点 跟 起点到终点是一样的）；

```cpp
#include <iostream>
#include <queue>
#include <cstring>
using namespace std;

int n, m, ans[1005][1005];
char mmap[1005][1005];
int dir[4][2] = {-1, 0, 0, 1, 1, 0, 0, -1};

int main() {
    memset(ans, -1, sizeof(ans));
    cin >> m >> n;
    queue<pair<int, int>> que;
    for(int i = 1; i <= m; ++i) {
        for(int j = 1; j <= n; ++j) {
            cin >> mmap[i][j];
            if(mmap[i][j] == '1') {
                que.push({i, j});
                ans[i][j] = 0;
            }
        }
    }
    int step = 1;
    while(!que.empty()) {
        int cnt = que.size();
        for(int i = 0; i < cnt; ++i) {
            int x = que.front().first;
            int y = que.front().second;
            que.pop();
            for(int j = 0; j < 4; ++j) {
                int xx = x + dir[j][0];
                int yy = y + dir[j][1];
                if(mmap[xx][yy] == 0 || ans[xx][yy] != -1) continue;
                ans[xx][yy] = step;
                que.push({xx, yy});
            }
        }
        ++step;
    }
    for(int i = 1; i <= m; ++i) {
        for(int j = 1; j <= n; ++j) {
            if(j > 1) cout << " ";
            cout << ans[i][j];
        }
        cout << endl;
    }
    return 0;
}
```

### 6.16 海贼OJ 305. 乳草的入侵（bfs）

- 返回走过最长的步数即可

```cpp
#include <iostream>
#include <queue>
using namespace std;

int m, n, x, y;
char mmap[105][105];
int dir[8][2] = {-1, -1, -1, 0, -1, 1, 0, -1, 0, 1, 1, -1, 1, 0, 1, 1};

int main() {
    cin >> n >> m >> y >> x;
    x = m + 1 - x;
    for(int i = 1; i <= m; ++i) {
        cin >> &mmap[i][1];
    }
    queue<pair<int, int>> que;
    que.push({x, y});
    mmap[x][y] = '*';
    int step = 0, ans = 0;
    while(!que.empty()) {
        int cnt = que.size();
        for(int i = 0; i < cnt; ++i) {
            x = que.front().first;
            y = que.front().second;
            ans = step;
            que.pop();
            for(int j = 0; j < 8; ++j) {
                int xx = x + dir[j][0];
                int yy = y + dir[j][1];
                if(mmap[xx][yy] != '.') continue;
                mmap[xx][yy] = '*';
                que.push({xx, yy});
            }
        }
        ++step;
    }
    cout << ans << endl;
    return 0;
}
```

### 6.17 海贼OJ 529. 龙与虫（多目标bfs，重点）

思路：

- 以目标为起点，找到所有可以直接攻击目标的位值（多目标）；
- 从起点出发，找到第一个可攻击位值；

```cpp
#include <iostream>
#include <queue>
#include <vector>
#include <string>
using namespace std;

const int dir[8][2] = {-1, 0, 0, 1, 1, 0, 0, -1, -1, -1, -1, 1, 1, 1, 1, -1};
string bfs(vector<string> mp, int sx, int sy, int ex, int ey) {
    if(mp.empty()) return 0;
    int m = mp.size(), n = mp[0].size();
    mp[ex][ey] = 'T';
    for(int i = 0; i < 8; ++i) {
        for(int j = 1; 1; ++j) {
            int xx = ex + dir[i][0] * j;
            int yy = ey + dir[i][1] * j;
            if(xx < 0 || yy < 0 || xx >= m || yy >= n || mp[xx][yy] == 'X') break;
            mp[xx][yy] = 'T';
        }
    }
    if(mp[sx][sy] == 'T') return "0";
    queue<pair<int, int>> que;
    que.push({sx, sy});
    mp[sx][sy] = 'X';
    int step = 1;
    while(!que.empty()) {
        int cnt = que.size();
        for(int i = 0; i < cnt; ++i) {
            int x = que.front().first;
            int y = que.front().second;
            que.pop();
            for(int j = 0; j < 4; ++j) {
                int xx = x + dir[j][0];
                int yy = y + dir[j][1];
                if(xx < 0 || yy < 0 || xx >= m || yy >= n || mp[xx][yy] == 'X') continue;
                if(mp[xx][yy] == 'T') return to_string(step);
                mp[xx][yy] = 'X';
                que.push({xx, yy});
            }
        }
        ++step;
    }
    return "Impossible!";
}

int main() {
    int m = 0, n = 0;
    cin >> m >> n;
    vector<string> mp(m);
    for(int i = 0; i < m; ++i) {
        cin >> mp[i];
    }
    int a = 0, b = 0, c = 0, d = 0;
    while(cin >> a >> b >> c >> d) {
        if(a == 0) break;
        cout << bfs(mp, c - 1, d - 1, a - 1, b - 1) << endl;
    }
    return 0;
}
```

### 6.18 海贼OJ 527. 飞跃原野

```cpp

```

## 7 搜索综合问题

搜索----不仅仅可以用来走地图，还可以干其它的

### 7.1 海贼OJ 81.小明回家

```cpp

```

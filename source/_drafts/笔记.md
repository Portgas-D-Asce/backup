---
title: 笔记
categories:
  - []
tags:
  - null
---

<!--more-->
## vim
编辑 /usr/share/vim/vimrc 这个文件， 这个vimrc配置是对所有的用户都生效的。

显示行号：set number

## 2 g++/gcc
### 2.1 一条龙
预处理 + 编译 + 链接，输出 a.out
```
g++ main.cpp
```
### 2.2 单独预处理
```
g++ -E main.cpp
```

### 2.3 单独编译
输出 main.o文件
```
g++ -c main.cpp
```

查看对象文件（.o）内容
```
nm -C main.o

U：表示需要从外部去寻找的
```
编译阶段发生的问题
```cpp
//多个声明没问题；
//声明 + 定义没问题；
//定义 + 定义：redefinition
```

### 2.4 单独链接
输出 a.out 文件
```
g++ main.o other.o
```

链接阶段发生的问题
```
undefined reference

multiple definition
```

redefinition 和 multiple definition 区别：
- redefinition 发生在编译阶段，一个文件中多次定义同一函数；
- multiple definition 发生在链接阶段，多个目标文件中出现同一函数；

### 2.5 附加包含目录
```
g++ -I./include -c main.cpp
```

### 2.6 附加库目录/附加库
```
g++ -L./lib main.o -lgtest -lpthread
```

## 3 printf带色
```cpp
#define COLOR(msg, code) "\033[0;1;"#code "m" msg
#define RED(msg) COLOR(msg, 31)
#define GREEN(msg) COLOR(msg, 32)
#define YELLOW(msg) COLOR(msg, 33)
#define BLUE(msg) COLOR(msg, 34)
```
## 4 内置宏
内置宏
- \_\_DATE\_\_
- \_\_TIME\_\_
- \_\_FILE\_\_
- \_\_LINE\_\_
- \_\_func\_\_（非标准）
- \_\_PRETTY_FUNCTION\_\_（非标准）


## 5 编译阶段
| 阶段 | 处理器 | 文件 |内容
|:-:|:-:|:-:|:-:|
|||源文件|
|预处理阶段|预处理器|中间文件（.i结尾）|宏替换
|编译阶段|编译器|ASCII码文件（.s结尾）|
|汇编阶段|汇编器|可重定位目标文件（.o结尾）|语法检查
|链接阶段|链接器|可执行目标文件|符号链接，定义的查找


## 6 Makefile
### 6.1 Hello World of Makefile
如何写

如何输出

### 6.2 多个目标
默认执行第一个目标

执行指定目标

多个目标之间的依赖关系

### 6.3 test main.cpp
示例

$@ 和 $< and $^

.cpp.o

@echo 和 @rm

完整 Makefile

### 6.4 动态链接库

ldd ./main


## 其它

1：启发式搜索方法有：Best-First，AStar，模拟退火，爬山算法，禁忌搜索，遗传算法，蚁群算法。
为何选用AStar，只要估价函数合适，我们总能选择到最优解。注意，A*总是用当前搜到的最优解替换之前搜索到的在Open表中的解，这样能保证Open表中始终是最有可能得到最优解的结点。但是可能会出现搜索深度过深，搜索树单一的情况，这时候需要使用迭代加深A*算法限定搜索树深度。
2：Open表用堆，Close表用无序表。

前 $n$ 个自然数的平方和公式：
$$1^2 + 2^2 + 3^2 + ... + n^2 = \frac{1}{6}n(n + 1)(2n + 1)$$

## C语言数组和指针
### 一维数组

```c
int a[] = {1, 2, 3, 4, 5};
int *p = a;
```
p 和 a 的值虽然相同，但：
- a是一个常指针；
- p是一个普通指针；


a 与 &a[0] 是等价的：
- 都表示数组中第一个 **元素的地址**；
- a + 1, &a[0] + 1 都表示数组中第二个元素的地址；


&a: 对数组名取地址，是 **数组的地址**； 其与 a 、&a[0] 虽然值相同，但它门不是等价的：
- &a + 1 : 加的是数组的大小（这里是 sizeof(int) * len = 4 * 5 = 20）；
- a + 1, &a[0] + 1 : 加的是一个 int 的大小（sizeof(int)）;

小结：
- a: 是一个常指针（不可以用其它指针为其赋值），其值为第一个元素的地址；
- &a[0]: 显然，对第一个元素取地址，也就是第一个元素的地址；
- &a: 对数组取地址，是数组的地址；虽然其值与第一个元素的地址是相同的，但是对他们进行增减的意义是不同的；

注意：
- 把 a 理解为一个常指针，其实也不好；对其取地址，也就是对一个常指针取地址，也就是 **指针的地址**；一般来说 指针的值 和 指针的地址 两者是不相等的，但 a == &a；

sizeof(a) 表示整个数组所占的字节数；

数组传递到形参后会变为指针；

### 二维数组
```
int a[3][4] = {{1, 2, 3, 4},
               {5, 6, 7, 8},
               {9, 10. 11, 12}};
```

## 刷题经验
### 数字digit相关
to_string 方法：
- to_string;
- 相关处理；
- stoi等；

自己实现方法：
- num % 10 and num /= 10;
- 相关处理；
- num = num * 10 + digit;




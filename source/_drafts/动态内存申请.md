---
title: 动态内存申请
author: Portgas·D·Asce
categories:
  - []
tags:
  - null
date: 2020-11-19 13:26:59
---

<!--more-->

## 1 概要
动态申请的内存是在堆区的，使用完成必须手动释放，否则会造成内存泄露。

**申请内存函数：**
- malloc
- calloc
- realloc

**释放申请内存：**
- free

**线程安全：**
- malloc、calloc、realloc都是线程安全的：it behaves as though only accessing the memory locations visible through its argument, and not any static storage.

**头文件：**
- malloc.h 和 stdlib.h 都可以，它们中均有以下内容：
```c
/* Allocate SIZE bytes of memory.  */
extern void *malloc (size_t __size) __THROW __attribute_malloc__
     __attribute_alloc_size__ ((1)) __wur;

/* Allocate NMEMB elements of SIZE bytes each, all initialized to 0.  */
extern void *calloc (size_t __nmemb, size_t __size)
__THROW __attribute_malloc__ __attribute_alloc_size__ ((1, 2)) __wur;

/* Re-allocate the previously allocated block in __ptr, making the new
   block SIZE bytes long.  */
/* __attribute_malloc__ is not used, because if realloc returns
   the same pointer that was passed to it, aliasing needs to be allowed
   between objects pointed by the old and new pointers.  */
extern void *realloc (void *__ptr, size_t __size)
__THROW __attribute_warn_unused_result__ __attribute_alloc_size__ ((2));

/* Re-allocate the previously allocated block in PTR, making the new
   block large enough for NMEMB elements of SIZE bytes each.  */
/* __attribute_malloc__ is not used, because if reallocarray returns
   the same pointer that was passed to it, aliasing needs to be allowed
   between objects pointed by the old and new pointers.  */
extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
__THROW __attribute_warn_unused_result__ __attribute_alloc_size__ ((2, 3));

/* Free a block allocated by `malloc', `realloc' or `calloc'.  */
extern void free (void *__ptr) __THROW;
```

## 2 内存申请
### 2.1 malloc
**函数原型：**
```c
//成功时，返回申请内存空间的首地址；失败时，返回NULL
void *malloc(size_t size);
```

**示例：**
```c
#include <stdio.h>
#include <malloc.h>

int main() {
    const int num = 10;
    int *p = (int *)malloc(num * sizeof(int));
    for(int i = 0; i < num; ++i) {
        printf("%d ", p[i]);
    }
    printf("\n");
    return 0;
}
/*输出
0 0 0 0 0 0 0 0 0 0
*/
```

### 2.2 calloc
**函数原型：**
```c
//成功则返回申请内存的首地址，否则返回NULL
void *calloc(size_t num, size_t size);
```
**作用：**
- 申请 $num$ 个 大小为 $size$ 的内存空间，并将所有字节初始化为 0；

**注意：**
- Due to the alignment requirements, the number of allocated bytes is not necessarily equal to num*size；
- Initialization to all bits zero does not guarantee that a floating-point or a pointer would be initialized to 0.0 and the null pointer value, respectively (although that is true on all common platforms)；

**示例：**
```c
#include <stdio.h>
#include <malloc.h>

int main() {
    const int num = 5;
    int *p = (int *)calloc(num, sizeof(int));
    float *q = (float *)calloc(num, sizeof(float));
    int **r = (int **)calloc(num, sizeof(int *));
    for(int i = 0; i < num; ++i) {
        printf("%d %f %p\n", p[i], q[i], r[i]);
    }
    return 0;
}
/* 输出
0 0.000000 (nil)
0 0.000000 (nil)
0 0.000000 (nil)
0 0.000000 (nil)
0 0.000000 (nil)
*/
```
### 2.3 realloc
**函数原型：**
```c
//成功时，返回申请内存空间的首地址；失败时，返回NULL
//当ptr为NULL时，相当于malloc
void *realloc(void *ptr, size_t new_size);
```

**作用：**
- 当发现 “申请的内存空间不够用 / 太大了” 重新申请一段 更大 / 更小 的内存空间；

**做了什么：**
- 重新申请一段 更大 / 更小 的内存空间；
- 完成原有数据（全部 / 部分）的迁移；
- 释放旧的内存空间；

**注意：**
- 当进行内存空间扩展时，额外部分的空间是未定义的。
- 申请成功后，ptr就失效了，访问其中内容属于未定以行为（相当于成了一个悬挂指针），所以使用的时候最好 ptr = realloc(ptr, num);

**示例：**
```c
#include <stdio.h>
#include <malloc.h>

int main() {
	const int num = 10;
    int *p = (int *)malloc(num * sizeof(int));
	printf("p = %p\n", p);
	for(int i = 0; i < num; ++i) {
		p[i] = i;
	    printf("%d ", p[i]);
	}
	printf("\n\n");
    
	//重新申请一块更大的内存空间
	int *q = realloc(p, 2 * num * sizeof(int));
	printf("p = %p  q = %p\n", p, q);
	for(int i = 0; i < 2 * num; ++i) {
	    printf("%d ", q[i]);
	}
	printf("\n");
	//访问已被释放的内存空间
	/*for(int i = 0; i < num; ++i) {
		p[i] = i;
	    printf("%d ", p[i]);
	}
	printf("\n\n");*/

    //重新申请一块更小的内存空间
	q = realloc(p, num / 2 * sizeof(int));
	printf("p = %p  q = %p\n", p, q);
	for(int i = 0; i < num / 2; ++i) {
	    printf("%d ", q[i]);
	}
	printf("\n");
	//访问已被释放的内存空间
	/*for(int i = 0; i < num; ++i) {
		p[i] = i;
	    printf("%d ", p[i]);
	}
	printf("\n\n");*/

    return 0;
}

```
## 3 内存释放
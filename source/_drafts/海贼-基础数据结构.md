---
title: 海贼-基础数据结构
author: Portgas·D·Asce
categories:
  - []
tags:
  - null
date: 2020-11-23 01:04:34
---

<!--more-->
## 1 什么是数据结构

## 2 什么是算法

## 3 数据结构的分类
按集合中元素的存储方式分：
- 线型数据结构：
  - 顺序存储结构；
  - 链式存储结构；
- 非线型数据结构：

按集合中元素之间的逻辑关系分类：
- 集合结构：集合种元素属于同一集合；
- 线型数据结构：集合中元素存在着一对一关系；
- 树型数据结构：集合种元素之间存在着一对多关系；
- 图型数据结构：集合中元素之间存在着多对多关系；

## 4 顺序表

```c
/*************************************************************************
    > File Name: vector.c
    > Author: pk
    > Mail: lupengkunmc@gmail.com 
    > Created Time: 2020年11月23日 星期一 02时50分05秒
 ************************************************************************/
#include <stdio.h>
#include <malloc.h>

#define ERROR 0
#define OK 1

typedef struct Vector {
    int size, capacity;
    int *data;
} Vector;

void init(Vector *v, int capacity) {
    v->capacity = capacity;
    v->size = 0;
    v->data = (int *)malloc(capacity * sizeof(int));
}

int expand(Vector *v) {
    printf("Expand from %d to %d\n", v->capacity, v->capacity << 1);
    v->capacity <<= 1;
    //为什么不直接下面这样？
    //分配内存可能会失败，失败回返回NULL，导致内存泄露
    int *temp = (int *)realloc(v->data, v->capacity * sizeof(int));
    if(temp == NULL) return ERROR;
    v->data = temp;
    return OK;
}

int insert(Vector *v, int p, int val) {
    if(p < 0 || p > v->size) return ERROR;
    if(v->size == v->capacity) {
        if(!expand(v)) return ERROR;
    }
    for(int i = v->size; i > p; --i) {
        v->data[i] = v->data[i - 1];
    }
    v->data[p] = val;
    ++v->size;
    return OK;
}

int delete(Vector *v, int p) {
    if(p < 0 || p >= v->size) return ERROR;
    for(int i = p + 1; i < v->size; ++i) {
        v->data[i - 1] = v->data[i];
    }
    --v->size;
    return OK;
}

int search(Vector *v, int val) {
    for(int i = 0; i < v->size; ++i) {
        if(v->data[i] == val) return i;
    }
    return -1;
}

void print(Vector *v) {
    for(int i = 0; i < v->size; ++i) {
        if(i) printf(" ");
        printf("%d", v->data[i]);
    }
    printf("\n");
}

void clear(Vector *v) {
    free(v->data);
}

int main() {
    const int n = 40;
    Vector *v = (Vector *)malloc(sizeof(Vector));
    init(v, n / 3);
    for(int i = 0; i < n; ++i) {
        insert(v, i, i);
    }
    print(v);

    for(int i = 0; i < n / 2; ++i) {
        delete(v, i);
    }
    print(v);

    clear(v);
    free(v);
    return 0;
}
```

## 5 链表
```c
/*************************************************************************
    > File Name: linkedlist.c
    > Author: pk
    > Mail: lupengkunmc@gmail.com 
    > Created Time: 2020年11月23日 星期一 19时20分56秒
 ************************************************************************/
#include <stdio.h>
#include <malloc.h>

#define ERROR 0
#define OK 1

typedef struct Node {
    int val;
    struct Node *next;
} Node;

Node *create_node(int val) {
    Node *node = (Node *)malloc(sizeof(Node));
    node->val = val;
    node->next = NULL;
}

typedef struct LinkedList {
    Node *head;
} LinkedList;

LinkedList *create_linkedlist() {
    LinkedList *linkedlist = (LinkedList *)malloc(sizeof(LinkedList));
    linkedlist->head = NULL;
    return linkedlist;
}

int insert(LinkedList *linkedlist, int val, int p) {
    //p == 0时，总能插入成功
    if(p == 0) {
        Node *node = create_node(val);
        node->next = linkedlist->head;
        linkedlist->head = node;
        return OK;
    }

    //初始化：当插入位值为1时，插入位值的前一个节点为 head；
    int cnt = 1;
    Node *pre = linkedlist->head;
    while(pre && cnt < p) {
        pre = pre->next;
        ++cnt;
    }

    //无法插入
    if(pre == NULL) return ERROR;
    
    //可以插入
    Node *node = create_node(val);
    node->next = pre->next;
    pre->next = node;
    return OK;
}

int delete(LinkedList *linkedlist, int p) {
    //头节点为空，总是不能删除
    if(linkedlist->head == NULL) return ERROR;

    //头节点不为空，p = 0，可以删除成功
    if(p == 0) {
        Node *temp = linkedlist->head;
        linkedlist->head = linkedlist->head->next;
        free(temp);
        return OK;
    }

    //初始化：要删除 1 位值上的节点时，其前一个节点为 head
    int cnt = 1;
    Node *pre = linkedlist->head;
    while(pre && cnt < p) {
        pre = pre->next;
        ++cnt;
    }

    //无法删除
    if(pre == NULL || pre->next == NULL) return ERROR;

    //可以删除
    Node *temp = pre->next;
    pre->next = temp->next;
    free(temp);
    return OK;
}

void reverse(LinkedList *linkedlist) {
    Node *pre = NULL;
    Node *head = linkedlist->head;
    while(head) {
        Node *temp = head->next;
        head->next = pre;
        pre = head;
        head = temp;
    }
    linkedlist->head = pre;
}

void print(LinkedList *linkedlist) {
    Node *cur = linkedlist->head;
    while(cur) {
        if(cur != linkedlist->head) printf(" ");
        printf("%d", cur->val);
        cur = cur->next;
    }
    printf("\n");
}

void clear(LinkedList *linkedlist) {
    Node *cur = linkedlist->head;
    while(cur) {
        Node *temp = cur;
        cur = cur->next;
        free(temp);
    }
    free(linkedlist);
}

int main() {
    LinkedList *linkedlist = create_linkedlist();
    const int n = 40;
    
    for(int i = 0; i < n; ++i) {
        insert(linkedlist, i, i);
    }
    print(linkedlist);

    for(int i = 0; i < n / 2; ++i) {
        delete(linkedlist, i);
    }
    print(linkedlist);

    reverse(linkedlist);

    print(linkedlist);

    clear(linkedlist);
    return 0;
}
```

## 6 循环队列
```c
/*************************************************************************
    > File Name: queue.c
    > Author: pk
    > Mail: lupengkunmc@gmail.com 
    > Created Time: 2020年11月23日 星期一 20时03分17秒
 ************************************************************************/
#include <stdio.h>
#include <malloc.h>

#define ERROR 0
#define OK 1

typedef struct Queue {
    int *data;
    int head, tail, size, capacity;
} Queue;

void init(Queue *q, int capacity) {
    q->capacity = capacity;
    q->size = 0;
    q->head = 0;
    q->tail = 0;
    q->data = (int *)malloc(capacity * sizeof(int));
}

void expand(Queue *q) {
    int *old = q->data;
    q->capacity <<= 1;
    q->data = (int *)malloc(q->capacity * sizeof(int));
    for(int i = 0; i < q->size; ++i) {
        q->data[i] = old[(q->head + i) % q->size];
    }
    q->head = 0;
    q->tail = q->size;
    free(old);
}

void push(Queue *q, int val) {
    if(q->size == q->capacity) {
        expand(q);
    }
    q->data[q->tail] = val;
    q->tail = (q->tail + 1) % q->capacity;
    ++q->size;
}

void pop(Queue *q) {
    q->head = (q->head + 1) % q->capacity;
    --q->size;
}

int front(Queue *q) {
    return q->data[q->head]; 
}

int empty(Queue *q) {
    return q->size == 0;
}

int size(Queue *q) {
    return q->size;
}

void print(Queue *q) {
    for(int i = 0; i < q->size; ++i) {
        if(i) printf(" ");
        printf("%d", q->data[(q->head + i) % q->capacity]);
    }
    printf("\n");
}

int main() {
    const int n = 40;
    Queue *q = (Queue *)malloc(sizeof(Queue));
    init(q, n / 3);
    for(int i = 0; i < n; ++i) {
        push(q, i);
    }
    print(q);
    for(int i = 0; i < n / 2; ++i) {
        printf("%d ", front(q));
        pop(q);
    }
    printf("\n");
    print(q);

    return 0;
}
```


---
title: 海贼-基础数据结构
author: Portgas·D·Asce
categories:
  - []
tags:
  - null
date: 2020-11-23 01:04:34
---

<!--more-->
## 1 什么是数据结构

## 2 什么是算法

## 3 数据结构的分类
按集合中元素的存储方式分：
- 线型数据结构：
  - 顺序存储结构；
  - 链式存储结构；
- 非线型数据结构：

按集合中元素之间的逻辑关系分类：
- 集合结构：集合种元素属于同一集合；
- 线型数据结构：集合中元素存在着一对一关系；
- 树型数据结构：集合种元素之间存在着一对多关系；
- 图型数据结构：集合中元素之间存在着多对多关系；

## 4 顺序表

```c
#include <stdio.h>
#include <malloc.h>

#define ERROR 0
#define OK 1

typedef struct Vector {
    int size, capacity;
    int *data;
} Vector;

void init(Vector *v, int capacity) {
    v->capacity = capacity;
    v->size = 0;
    v->data = (int *)malloc(capacity * sizeof(int));
}

int expand(Vector *v) {
    printf("Expand from %d to %d\n", v->capacity, v->capacity << 1);
    v->capacity <<= 1;
    //为什么不直接下面这样？
    //分配内存可能会失败，失败回返回NULL，导致内存泄露
    int *temp = (int *)realloc(v->data, v->capacity * sizeof(int));
    if(temp == NULL) return ERROR;
    v->data = temp;
    return OK;
}

int insert(Vector *v, int p, int val) {
    if(p < 0 || p > v->size) return ERROR;
    if(v->size == v->capacity) {
        if(!expand(v)) return ERROR;
    }
    for(int i = v->size; i > p; --i) {
        v->data[i] = v->data[i - 1];
    }
    v->data[p] = val;
    ++v->size;
    return OK;
}

int delete(Vector *v, int p) {
    if(p < 0 || p >= v->size) return ERROR;
    for(int i = p + 1; i < v->size; ++i) {
        v->data[i - 1] = v->data[i];
    }
    --v->size;
    return OK;
}

int search(Vector *v, int val) {
    for(int i = 0; i < v->size; ++i) {
        if(v->data[i] == val) return i;
    }
    return -1;
}

void print(Vector *v) {
    for(int i = 0; i < v->size; ++i) {
        if(i) printf(" ");
        printf("%d", v->data[i]);
    }
    printf("\n");
}

void clear(Vector *v) {
    free(v->data);
}

int main() {
    const int n = 40;
    Vector *v = (Vector *)malloc(sizeof(Vector));
    init(v, n / 3);
    for(int i = 0; i < n; ++i) {
        insert(v, i, i);
    }
    print(v);

    for(int i = 0; i < n / 2; ++i) {
        delete(v, i);
    }
    print(v);

    clear(v);
    free(v);
    return 0;
}
```


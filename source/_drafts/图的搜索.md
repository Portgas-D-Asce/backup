---
title: 图的搜索
categories:
- [Data Structure & Algorithm]
tags:
  - 图论
date: 2020-04-29 12:47:56
---
本文将介绍两种图的搜索算法：广度优先搜索（breadth first search, bfs） 和 深度优先搜索（depth first search, dfs）。
<!--more-->

图的搜索，有两种方式：bfs 和 dfs。无论是哪种搜索方式，都会对节点的访问状态进行标记，每个节点都存在三种状态（算法导论）：
- white：节点还未开始搜索；
- gray：节点开始被搜索；
- black：以其为根节点的子树均已访问完成。


## bfs
实现：队列 + 标记
```cpp
void bfs(const vector<vector<int>>& outgoing) {
    vector<int> state(outgoing.size(), 0);
    queue<int> que;
    que.push(0);
    while(!que.empty())
    {
        int u = que.front();
        que.pop();
        //cout << u << endl;
        for(auto v : outgoing[u])
        {
            if(state[v]) continue;
            state[v] = 1;
            que.push(v);
        }
        state[v] == 2;
    }
}
```

## dfs
实现：递归 + 标记
```cpp
void recursion(const vector<vector<int>>& outgoing, vector<int>& state, int u) {
    //cout << u << endl;
    state[u] = 1;
    for(auto v : outgoing[u])
    {
        if(state[v]) continue;
        recursion(outgoing, state, v);
    }
    state[u] = 2;
}
void dfs(vector<vector<int>>& outgoing) {
    vector<int> state(outgoing.size(), 0);
    for(int i = 0; i < outgoing.size(); ++i)
    {
        if(state[i]) continue;
        recursion(outgoing, state, 0);
    }
}
```

## 拓扑排序
目标：对一个有向图进行拓扑排序：
- 如果有向图同存在环，则返回 false；
- 如果图为 有向无环图（DAG），则返回true 和 拓扑排序结果；

### Kahn
实现方式：迭代的方式；

正向图 + 入度

原理：若果一个节点的入度为 0 ，则表明其前面（按照topo顺序）不存在节点。
```cpp
bool topo_sort(const vector<vector<int>>& outgoing, vector<int>& indeg, vector<int> topo) {
    int n = outgoing.size();
    vector<int> zero_deg;
    for(int i = 0; i < n; ++i)
        if(indeg[i] == 0)
            zero_deg.push_back(i);

    while(!zero_deg.empty())
    {
        int u = zero_deg.back();
        zero_deg.pop_back();
        topo.push_back(u);
        for(auto v : outgoing[u])
            if(--indeg[v] == 0)
                zero_deg.push_back(v);
    }
    return topo.size() == n;
}
```
时间复杂度：$O(V + E)$

注意：
- 入度为 0 的集合 zero_deg 没必要用队列；
- topo排序中未出现的节点构成环；

### dfs
实现方式：递归的方式

按照dfs搜索图中节点，当节点访问完成，将其加入到拓扑排序结果 **最前面**
- 通常是放在后面，最后反转下即可；

实现：只需要简单修改下 dfs 即可：
```cpp
bool recursion(vector<vector<int>>& outgoing, vector<int>& state, int u, vector<int>& topo) {
    state[u] = 1;
    for(auto v : outgoing[u])
    {
        if(state[v] == 1) return false;
        if(!recursion(outgoing, state, v, topo)) return false;
    }
    topo.push_back(u);
    state[u] = 2;
    return true; 
}

bool topo_sort(vector<vector<int>>& outgoing, vector<int>& topo) {
    vector<int> state(outgoing.size(), 0);
    for(int i = 0; i < outgoing.size(); ++i)
    {
        if(state[i]) continue;
        if(!recursion(outgoing, state, i, topo)) return false;
    }
    reverse(topo.begin(), topo.end());
    return true;
}
```
注意：
- dfs 好想就是按照 topo_sort 的顺序访问节点的？真的是这样吗？不是的，dfs 不一定是从入度为 0 的节点开始搜索的，所以不能以 “前序遍历” 的方式，而应该用 “后序遍历” + “反转” 的方式。


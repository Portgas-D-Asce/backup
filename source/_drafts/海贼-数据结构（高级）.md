---
title: 海贼-数据结构（高级）
author: Portgas·D·Asce
categories:
  - []
tags:
  - null
date: 2020-12-19 17:19:53
---

<!--more-->


# 1 二叉搜索树
性质：
- 左子树 < 根节点；
- 右子树 > 根节点；
- 中序遍历结果，是一个有序序列；

## 1.1 插入
插入新节点，一定会作为叶子节点；

## 1.2 删除
### 1.2.1 前驱和后继
按中序遍历对节点进行排序，得到一个有序序列
- 当前节点的前一个节点称为它的前驱；
- 当前节点的后一个节点称为它的后继；

前驱和后继的含义：
- 前驱：
  - 当左子树存在时，前驱为左子树中最大的节点；
  - 当左子树不存在时，前驱？？？？？？
  - 前驱一定没有右孩子；
- 后继：
  - 当右子树存在时，后继为右子树中最小的节点；
  - 当右子树不存在时，后继为？？？？？？？
  - 后继一定没有左孩子；
- 前驱 和 后继 的度最大为 1；

### 1.2.2 删除节点 
删除节点：
- 度为 0 的节点：直接删除；
- 度为 1 的节点：将 “孤儿子树” 挂到其父节点上面去；
- 度为 2 的节点：可以转化为删除度为 1 或度为 0 的节点；
- 将要删除的节点与其前驱或后继进行交换，将问题转化为删除度不为2的节点（前驱/后继）

## 1.3 查找
- 插入的顺序会影响最后生成的树形结构；
- 不同的树形结构查找效率不同；

平均查找次数：所有节点的查找次数之和 / 节点的个数；

## 1.4 实现
```cpp
#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
    int val;
    struct Node *left, *right;
}Node;

Node *init(int val) {
    Node *p = (Node *)malloc(sizeof(Node));
    p->val = val;
    p->left = p->right = NULL;
    return p;
}

void clear(Node *root) {
    if(root == NULL) return;
    clear(root->left);
    clear(root->right);
    free(root);
}

Node *insert(Node *root, int val) {
    if(root == NULL) return init(val);
    if(root->val == val) return root;
    if(val < root->val) {
        root->left = insert(root->left, val);
    } else {
        root->right = insert(root->right, val);
    }
    return root;
}

Node *predecessor(Node *root) {
    Node *temp = root->left;
    while(temp->right) temp = temp->right;
    return temp;
}

Node *erase(Node *root, int val) {
    if(root == NULL) return NULL;
    if(val < root->val) {
        root->left = erase(root->left, val);
    } else {
        root->right = erase(root->right, val);
    } else {
        if(root->left == NULL || root->right == NULL) {
            Node *temp = root->left ? root->left : root->right;
            free(root);
            return temp;
        } else {
            Node *temp = predecessor(root);
            root->val = temp->val;
            root->left = erase(root->left, temp->val);
        }
    }
    return root;
}

int search(Node *root, int val) {
    if(root == NULL) return 0;
    if(root->val == val) return 1;
    if(val < root->val) return search(root->left,val);
    return search(root->right, val);
}

void print(Node *root) {
    int left = root->left ? root->left->val : 0;
    int right = root->right ? root->right->val : 0;
    printf("(%d, %d, %d)\n", root->val, left, right);
}

void output(Node *root) {
    if(root == NULL) return;
    output(root->left);
    print(root);
    output(root->right);
    printf("(%d %d %d)");
}

int main() {
    int op, val;
    while(scanf("%d%d", &op, &val) != EOF) {
        switch(op) {
            case 0: printf("search %d, result : %d\n", val, search(root, val)); break;
            case 1: root = insert(root, val); break;
            case 2: root = erase(root, val); break;
        }
        if(op) {
            output(root);
        }
    }
}
```

## 扩展内容
### 二叉排序树得删除打吗优化；
### 如何解决排名相关检索需求；
### 解决 Top-K 问题；
### 二叉排序树和快速排序关系

# AVL树（平衡二叉搜索树）
性质：
- 左子树和右子树的高度差不超过1；

思考：
- 二叉搜索树节点数量范围：$[h, 2^h -1]$
- AVL树节点数量范围：$[1.5^h, 2^{h - 1}]$
  - low(h) = low(h - 1) + low(h - 2) + 1;
- 树高 = 生命长度，

## 左/右旋旋
在保证二叉搜索树性质的同时，降低左右子树的高度差；
- 左旋：
- 右旋：

失衡类型：
- LL类型：h1 = h2 + 1 = max(h3, h4) + 2
- LR类型：
- RL类型：
- RR类型：

## 代码
```cpp
#include <stdio.h>
#include <stdlib.h>
#define L(n) (n ? n->lchild : NULL)
#define R(n) (n ? n->rchild : NULL)
#define H(n) (n->h)

typedef struct Node {
    int key, h;
    struct Node *lchild, *rchild;
}Node;

Node *getNewNode(int key) {

    Node *p = (Node *)malloc(sizeof(Node));
    p->key = key;
    p->h = 1;
    p->lchild = p->rchild = NULL:
    return p;
}

Node *maintain(Node *root) {
    if(abs(H(L(root)) - H(R())))
}

void update_height(Node * root) {
    root->h = H()
}

Node *insert(Node *root, int key) {
    if(root == NULL) return getNewNode(key);
    if(root->key == key) return root;
    if(key < root->key) {

    } else {
        root->rchild = insert(root->rchild, key);
    }
    update_height(root);
    return root;
}

Node *predecessor(Node *root) {
    Node *temp = root->lchild;
    while(temp->rchild) temp = temp->rchild;
    return temp;
}

Node *erase(Node *root, int key) {
    if(root == NULL) return NULL;
    if(key < root->key) {
        root->lchild = erase(root->lchild, key);
    } else if(key > root->key){
        root->rchild = erase(root->rchild, key);
    } else {
        if(root->lchild == NULL || root->rchild == NULL) {
            Node *temp = root->left ? root->left : root->right;
            free root;
            return temp;
        } else {
            Node *temp = predecessor(root);
            root->key = temp->key;
            root->lchild = 
        }
    }
    update_height(root);
}

void clear(Node *root) {
    if(root == NULL) return;
    clear(root->lchild);
    clear(root->rchild);
    free(root);
    return;
}
```

# 红黑树
五个条件：
- 每个节点非黑即红；
- 根节点是黑色；
- 叶节点（NIL）是黑色；
- 如果一个节点是红色，则它的两个子节点都是黑色的；
- 从根节点出发到所有叶节点路径上，黑色节点数量相同；

理解：
- 第四、五条隐含了，红黑树中最长路径是最短路径长度的两倍；
- 本质上，红黑树也是通过树高来控制平衡的；
- 红黑树比AVL树高控制条件更松散，红黑树在发生节点插入和删除后，发生调整的概率，比AVL树要更小；

插入节点是什么色的？（答案：红色）
- 如果插入黑色，那条路径的黑高会 +1，则一定需要调整；
- 如果插入红色，可能需要调整；



冲突情况：
- 第一种情况：叔父节点是红色，父亲和儿子都是红色（冲突）：爷爷把父亲和叔父红帽子拿去了；

- 第二种情况：叔父节点是黑色，父亲和儿子都是红色（冲突），根据情况（LL， LR，RL，RR），选择小旋和大旋，旋完之后调整颜色（两种方法，黑红红，红黑黑）；

```cpp
#include <stdlib.h>
#include <stdio.h>

typedef struct Node {
    int key;
    int color;//红0黑1双重黑色2
    struct Node *lchild, *rchild;
} Node;

Node __NIL;
#define NIL (&__NIL)

void init_NIL() {


}

Node *geNewNode(int key) {

    Node *p = (Node *)malloc(sizeof(Node));
    p->key = key;
    p->color = 0;
    p->lchild = p->rchild = NIL;
    return p;
}

int has_red_child(Node * root) {
    return root->lchild->color == 0 || root->rchild->color == 0;
}

Node *left_rotate(Node *root) {
    Node *temp = root->rchild;
    
}

Node *

Node *insert_maintain(Node *root) {
    if(!has_red_child(root)) return root;
    if(root->lchild->color == 0 && root->rchild->color == 0) {
        root->color = 0;
        root->lchild->color = root->rchild->color = 1;
        return root;
    }
    int flag = 0;
    if(flag == 0) return root;
    if(root->lchild->color == 0 && has_red_child(roor->lchild)) flag = 1;
    if(root->rchild->color == 0 && has_red_child(root->rchild)) flag = 2;
    if(flag == 1) {
        if(root->lchild->rchild->color == 0) {
            root->lchild = left_rotate(root->lchild);
        }
        root = right_rotate(root);
    } else {
        if(root->rchild->lchild->color == 0) {
            root->rchild = right_rotate(root->rchild);
        }
        root = left_rotate(root);
    }
    root->color = 0;
    root->lchild->color = root->rchild->color = 1;
    return root;
}

Node *insert(Node *root, int key) {
    root = __insert(root, key);
    root->color = 1;
    return root;
}

Node *insert(Node *root, int key) {

    if(root == NIL) return getNewNode(key);
    if(root->key == key) return root;
    if(key < root->key) {
        root->lchild = __insert(root->lchild, key);
    } else {
        root->rchild = __insert(root->rchild, key);
    }
    return insert_maintain(root);
}

void clear(Node *root) {
    if(root == NIL) return;
    clear(root->lchild);
    clear(root->rchild);
    free(root);
}

void print(Node *root) {

}

void output(Node *root) {
    if(!root) return;
    print(root);
    output(root->lchild);
    output(root->rchild);
}

int main() {
    int op, val;
    while(scanf("%d%d", &op, &val) != EOF) {
        switch(op) {
            case 1: root = insert(root,val);break;
            output(root);

        }
    }
    return 0;
}
```
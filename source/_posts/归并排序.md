---
title: 归并排序
author: Portgas·D·Asce
categories:
- [Data Structure & Algorithm]
tags:
- 排序
date: 2020-03-18 23:59:00
---

归并排序（Merge Sort）
<!--more-->
## 1 理论
**1、原理**
采用分治策略将原数组一分为二，划分为规模较小的两个子数组，递归地对子数组进行排序，然后合并已排序子数组从而完成原数组地排序；

- 时间复杂度 $O(nlgn)$，空间复杂度 $O(n)$ ；
- 稳定；
- 要注意 **哨兵** 也是主角之一；

**2、哨兵**

- 不能降低相关操作的渐进时间界，但可以降低常数因子，提高效率；
- 在循环语句种使用哨兵的好处往往是简化边界处理，使代码更加的简洁，而非提高速度；
## 2 代码
```
#include <iostream>
#include <vector>
#include <limits>
using namespace std;

void merge(vector<int>& nums, int p, int q, int r) {
	int n1 = q - p + 1;
	int n2 = r - q;
	vector<int> left(n1 + 1);
	vector<int> right(n2 + 1);
	for (int i = 0; i < n1; i++)
		left[i] = nums[i + p];
	for (int i = 0; i < n2; i++)
		right[i] = nums[i + q + 1];

	//哨兵
	left[n1] = numeric_limits<int>::max();
	right[n2] = numeric_limits<int>::max();

	for (int i = p, idxL = 0, idxR = 0; i <= r; i++)
	//必须要有等号，不然不是稳定的
		nums[i] = left[idxL] <= right[idxR] ? left[idxL++] : right[idxR++];
}

void mergeSort(vector<int>& nums, int p, int r) {
	if (p < r)
	{
		int q = (p + r) >> 1;
		mergeSort(nums, p, q);
		mergeSort(nums, q + 1, r);
		merge(nums, p, q, r);
	}
}

int main()
{
	vector<int> nums = { 1,3,2,8,7,7,6,4,9,5 };
	mergeSort(nums, 0, nums.size() - 1);
	for (int i = 0; i < nums.size(); i++)
	{
		cout << nums[i] << endl;
	}
	system("pause");
    return 0;
}
//输出
1
2
3
4
5
6
7
7
8
9
```
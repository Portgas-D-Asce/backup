---
title: 数组变量和指针变量
author: Portgas·D·Asce
categories:
  - [C/C++]
tags:
  - C语言
date: 2020-10-09 01:45:49
---
数组变量 和 指针变量 在使用的时候真的是太像了，本文将对这两者内容进行深入分析。
<!--more-->
如果对以下内容有了清晰的认识，本文的任务也就算完成了。

目标 1：明确一些概念。
- 数组变量；
- 指针变量；
- 元素为指针的数组（要不要称呼为 指针数组？）；
- 指向数组的指针（叫 数组指针 好想也挺好的）；
- 指针的指针；
- 扩展的还有：函数变量 和 函数指针；

目标 2：准确识别
- 如何区分 数组变量（数组名） 和 其所对应的 指针变量 ？
- 如何区分 函数变量（函数名） 和 函数指针？

目标 3：理解
- 如何理解对多维数组取地址所得到的指针变量？

## 1 数组变量
<!--数组名：就是一个数组变量，只是行为表现得像一个常指针。-->

首先理解两个东西：int \*a[3] 和 int (\*a)[3]
- **int \*a[3]**： a 是一个长度为 3 的数组，其中元素为 int \* 类型的指针变量；
- **int (\*a)[3]** : a 是一个指针，指向一个 长度为 3 的一维数组；

ps：**int \*a[3]** 理解起来很简单，不是重点； **int (\*a)[3]** 才是重头戏！！！

### 1.1 一维数组
```c
int a[] = {1, 2, 3, 4, 5};
int *p = a;

//error
//a = p;
```
p 和 a 在使用的时候真的很像：
- p 和 a 都表示数组中第一个元素的地址（即，a[0] 和 p[0] 都表示数组中第一个元素）；
- a + 1 和 p + 1 都表示数组中第二个元素的地址（即，\*(a + 1) 和 \*(p + 1) 都表示数组中第二个元素）；

但是，只是用起来像而已，它俩的本质是不同的：
- p： 是一个指针变量，对其取地址得到的是指针的指针，恒有，&p != p；
- a： 是一个数组变量，对其取地址得到的是数组的指针，恒有，&a == a （只是值相等，本质上两者是不同的，左侧是指向数组的指针，右侧是数组变量）；
- 扩展下，对于函数变量 func 和 函数指针 p_func 也是同样的道理：
  - &func 表示对函数取地址，得到的是函数的首地址，跟 func 的值是一样的，也就是 &func == func 恒成立；
  - &p_func 表示对指针取地址，得到的是指针的指针，跟 p_func 肯定是不一样的，也就是 &p_func != p_func 是横成立的；

先来回忆一下 & 取地址运算符：a[0]，表示数组中第一个元素，对其取地址 &a[0] 就是数组中第一个元素的地址， &a[0] + 1 表示数组中第二个元素的地址（这和 a、p 是一模一样的）。

那 &a 又表示什么呢？ 
- &a 是对数组变量 a 取地址，也就是： &a 是一个指针，指向一个数组；
- 在一开始已经说过了 int (*x)[3] 中的 x 表示一个指针，指向 一个长度为 3 的数组； 显然，&a 的本质就是这么个东西；

已经知道 &a 是一个指针，指向一个数组，那 &a + 1 又表示什么呢？
- &a 通常被称作 **数组的地址** ，而非数组中第一个元素的地址；
- &a + 1 不是数组中第二个元素的地址，而是整个数组的尾地址（最后一个元素后面那个地址）；

实验代码及结果：
```c
#include <stdio.h>

int main() {
    int a[5] = {1, 2, 3, 4, 5};
    printf("a = %p\n", a);
    printf("a + 1 = %p\n", a + 1);
    printf("&a = %p\n", &a);
    printf("&a[0] = %p\n", &a[0]);
    printf("&a[1] = %p\n", &a[1]);
    printf("a + 1 = %p\n", a + 1);
    printf("&a[0] + 1 = %p\n", &a[0] + 1);
    printf("&a + 1 = %p\n", &a + 1);
    printf("*a = %d\n", *a);
    return 0;
}

//输出
a = 0x7ffcfc26d500
a + 1 = 0x7ffcfc26d504
&a = 0x7ffcfc26d500
&a[0] = 0x7ffcfc26d500
&a[1] = 0x7ffcfc26d504
a + 1 = 0x7ffcfc26d504
&a[0] + 1 = 0x7ffcfc26d504
&a + 1 = 0x7ffcfc26d514
*a = 1
```

### 1.2 二维数组
```c
int a[2][3] = {{1, 2, 3},{4， 5, 6}};
```
\[\] 取地址运算符，结合方向是从左到右：
- 先将 a\[2\] 看作一个整体；
- 剩下 int a[2][3] 可以理解为：声明了一个长度为 3 的数组，数组名为 a[2]；
- a[2] 又是一个数组；

上面解释得确实有点牵强哈，总之，有以下结论：
- a 是一个长度为 2 的数组，其中元素均为长度为 3 的数组；也就是说 a 是 数组的数组；

a 是二维数组的数组名，它代表什么呢？
- 对于一维数组，数组名的含义是：数组中第一个元素的地址；二维数组也是一样的；
- 因此，a 是二维数组中第一个元素（第一个长度为 3 的数组）的地址；这不就是 指向数组的指针；
- 于是，a + 1 指向二维数组中第二个元素（第二个长度为 3 的数组）也就不难理解了；

a[0],a[1]又该如何理解呢？
- a[0]：二维数组 a 的第一个长度为 3 的数组的数组名；
- a[1]：二维数组 a 的第二个长度为 3 的数组的数组名；

&a 表示对二维数组取地址，这又该如何理解呢？
- &a 可以这样来理解：还是对一个一维数组取地址，只不过这个一维数组中的元素还是数组（而不是 int 类型变量）;
- 按道理说 &a + 1 应该是二维数组 a 的尾地址；但实际上 &a + 1 是会报错的；

结合以上两点内容，就不难理解：对于一个多维数组 a[x][y]...[m]
- &a, a, &a[0], a[0], &a[0][0], a[0][0], &a[0][0][0]...[0]虽然它们的含义是不同的，但是的它们的值（地址）都是相等的，都是这个多维数组的地址；


实验代码及结果
```c
#include <stdio.h>

int main() {
    int a[][3] = {{1, 2, 3},{4, 5, 6}};
    printf("a = %p\n", a);
    printf("&a = %p\n", &a);
    printf("a + 1 = %p\n", a + 1);
    //printf("&a + 1 = %p\n" &a + 1);

    printf("a[0] = %p\n", a[0]);
    printf("a[0] + 1 = %p\n", a[0] + 1);
    printf("&a[0] = %p\n", &a[0]);
    printf("&a[0] + 1 = %p\n", &a[0] + 1);

    printf("a[1] = %p\n", a[1]);
    printf("a[1] + 1 = %p\n", a[1] + 1);
    printf("&a[1] = %p\n", &a[1]);
    printf("&a[1] + 1 = %p\n", &a[1] + 1);

    printf("a[0][0] = %d\n", a[0][0]);
    printf("&a[0][0] = %p\n", &a[0][0]);
    printf("&a[0][0] + 1 = %p\n", &a[0][0] + 1);
    printf("&a[0][1] = %p\n", &a[0][1]);

    printf("a[1][0] = %d\n", a[1][0]);
    printf("&a[1][0] = %p\n", &a[1][0]);
    printf("&a[1][0] + 1 = %p\n", &a[1][0] + 1);
    printf("&a[1][1] = %p\n", &a[1][1]);

    return 0;
}

//输出
a = 0x7ffd5a756830
&a = 0x7ffd5a756830
a + 1 = 0x7ffd5a75683c
a[0] = 0x7ffd5a756830
a[0] + 1 = 0x7ffd5a756834
&a[0] = 0x7ffd5a756830
&a[0] + 1 = 0x7ffd5a75683c
a[1] = 0x7ffd5a75683c
a[1] + 1 = 0x7ffd5a756840
&a[1] = 0x7ffd5a75683c
&a[1] + 1 = 0x7ffd5a756848
a[0][0] = 1
&a[0][0] = 0x7ffd5a756830
&a[0][0] + 1 = 0x7ffd5a756834
&a[0][1] = 0x7ffd5a756834
a[1][0] = 4
&a[1][0] = 0x7ffd5a75683c
&a[1][0] + 1 = 0x7ffd5a756840
&a[1][1] = 0x7ffd5a756840
```

### 1.3 数组变量退化为指针变量
我们都知道，数组变量从实参传递到形参时，会退化为指针，但这句话又该如何理解呢？
- 退化就是 从一个数组变量 变成了 一个指针变量；这意味着 &a ：从对一个数组变量取地址（得到一个指向数组的指针）变成了对一个指针变量取地址（得到一个指向指针的指针）；
- 对于一维数组来说，退化就是由一个数组变量变成了一个普通指针；对于二维（多维）数组来说，退化就是从数组变量变成了一个指向数组的指针变量；

实验代码及结果
```c
#include <stdio.h>

void degrade(int a[][3]) {
    printf("a = %p\n", a);
    printf("&a = %p\n", &a);
    printf("a + 1 = %p\n", a + 1);
    //printf("&a + 1 = %p\n" &a + 1);
    
    printf("a[0] = %p\n", a[0]);
    printf("a[0] + 1 = %p\n", a[0] + 1);
    printf("&a[0] = %p\n", &a[0]);
    printf("&a[0] + 1 = %p\n", &a[0] + 1);
    
    printf("a[1] = %p\n", a[1]);
    printf("a[1] + 1 = %p\n", a[1] + 1);
    printf("&a[1] = %p\n", &a[1]);
    printf("&a[1] + 1 = %p\n", &a[1] + 1);
    
    printf("a[0][0] = %d\n", a[0][0]);
    printf("&a[0][0] = %p\n", &a[0][0]);
    printf("&a[0][0] + 1 = %p\n", &a[0][0] + 1);
    printf("&a[0][1] = %p\n", &a[0][1]);
    
    printf("a[1][0] = %d\n", a[1][0]);
    printf("&a[1][0] = %p\n", &a[1][0]);
    printf("&a[1][0] + 1 = %p\n", &a[1][0] + 1);
    printf("&a[1][1] = %p\n", &a[1][1]);
}
int main() {
    int a[][3] = {{1, 2, 3},{4, 5, 6}};
    degrade(a);
    return 0;
}

//输出
a = 0x7fff9628de70
&a = 0x7fff9628de58
a + 1 = 0x7fff9628de7c
a[0] = 0x7fff9628de70
a[0] + 1 = 0x7fff9628de74
&a[0] = 0x7fff9628de70
&a[0] + 1 = 0x7fff9628de7c
a[1] = 0x7fff9628de7c
a[1] + 1 = 0x7fff9628de80
&a[1] = 0x7fff9628de7c
&a[1] + 1 = 0x7fff9628de88
a[0][0] = 1
&a[0][0] = 0x7fff9628de70
&a[0][0] + 1 = 0x7fff9628de74
&a[0][1] = 0x7fff9628de74
a[1][0] = 4
&a[1][0] = 0x7fff9628de7c
&a[1][0] + 1 = 0x7fff9628de80
&a[1][1] = 0x7fff9628de80
```
## 2 指针
首先分清以下三种情况
- int \*\*p：指针的指针；
- int *a[3]: 元素为指针的数组；
- int (*a)[3]: 指向数组的指针；

经常遇到的问题：
- 尝试用 指针的指针 去接收 指向数组的指针；
- 虽然通过强制转化等方式可以勉强实现，但使用起来非常不方便，不建议使用；

```c
int a[2][3] = {{1, 2, 3}, {4, 5, 6}};
//error
//int **b = a;
```
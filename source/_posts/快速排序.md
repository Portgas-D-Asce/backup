---
title: 快速排序
author: Portgas·D·Asce
categories:
- [Data Structure & Algorithm]
tags:
- 排序
date: 2020-03-18 23:58:43
---
快速排序（Quick Sort）
<!-- more -->
## 1 理论
原理：快速排序利用 **主元** 将原数组划分成两部分，左侧部分均小于主元，右侧部分均大于等于主元，最后将主元放在中间；本质就是采用分治策略将原问题划分为两个子问题，递归地进行求解。

- 时间复杂度取决于划分是否均衡；最坏时间复杂度为 $O(n^2)$ ；期望时间复杂度为 $O(n \lg n)$ ，且 $O(n \lg n)$ 中隐含的常数因子非常小；
- 空间复杂度 $O(1)$ ；
- 不稳定；
## 2 代码
```
#include <iostream>
#include <vector>
#include <time.h>
using namespace std;

int partition(vector<int>& nums, int p, int r) {
	int q = p;
	for (int i = p; i < r; i++)
	{
		if (nums[i] < nums[r])
			swap(nums[i], nums[q++]);
	}
	swap(nums[r], nums[q]);
	return q;
}

int randomizedPartition(vector<int>& nums, int p, int r) {
	srand((unsigned)time(NULL));
	int temp = rand() % (r - p + 1) + p;
	swap(nums[r], nums[temp]);
	return partition(nums, p, r);
}

void quickSort(vector<int>& nums, int p, int r) {
	if (p < r)
	{
		//int q = partition(nums, p, r);
		int q = randomizedPartition(nums, p, r);
		
		quickSort(nums, p, q - 1);
		quickSort(nums, q + 1, r);
	}
}

int main()
{
	vector<int> nums = { 1,3,4,2,7,6,5,9,8,8 };
	quickSort(nums, 0, nums.size() - 1);
	for (int i = 0; i < nums.size(); i++)
	{
		cout << nums[i] << endl;
	}
	system("pause");
    return 0;
}

//输出
1
2
3
4
5
6
7
8
8
9
```

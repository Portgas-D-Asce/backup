---
title: Binary Search
tags:
  - 二分法查找
categories:
  - [Data Structure & Algorithm, Algorithm]
date: 2020-01-02 20:59:53
---
二分法查找。

<!-- more -->

对于一个随机数组，判断某个元素是否存在，显然需要线性时间；那么，如果数组有序，能否对时间复杂度进行提升呢？答案当然是肯定的。binary search 算法可以在 $O(lgn)$ 的时间复杂度下出色的完成任务。原理很简单，就不再赘述，贴一下实现代码，然后列一下需要注意的几点。
## 1 代码
```
bool binarySearch(const vector<int>& nums, int k) {
    if(nums.empty()) return false;
	int p = 0, r = nums.size() - 1;
	//注意，不要少了等号
	while(p <= r)
	{
		int q = p + r >> 1;
		if(nums[q] == k) return q;
		//注意不要忘了加１/减１
		nums[q] > k ?  r = q - 1 : p = q + 1;
	}
	return false;
}
```
## 2 注意
- nums.size() - 1，肯定是不能直接使用的，需要先判断数组是否为空；
- 每次循环都是在 **闭区间[p,r]** 内查找，可能是nums[p] == k，也可能是nums[r] == k；
- 假设数组为：...3,7,9...当p指向3，r指向9，目标值k为7时，当前循环没有查找到，需要进行下一次循环（p与r同时指向7）才能查找到结果。可见，循环判断 p <= r 中等号是不可缺少的；
- 由于之前已经判断过是否等于目标值，所以，后面收缩区间时，可以放心大胆地+1或-1，减少收缩次数；
- 当允许数组中存在相同元素，且需要返回索引（查找到，返回索引，未查找到，返回-1）时，返回值可能是与目标值相等的任意元素的索引（eg. ...3,3,3...返回的：可能是第一个3的索引，也可能是第二个3的索引，还可能是第三个3的索引）；
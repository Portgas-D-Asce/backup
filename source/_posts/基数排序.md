---
title: 基数排序
categories:
- [Data Structure & Algorithm, Algorithm]
tags:
- 排序
date: 2020-03-19 00:00:34
---

# 基数排序（Radix Sort）
## 1 理论
这张图真是太直观了。。。
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019061217322687.gif)
原理：先按照个位上的数字将原数组中元素划分到不同的桶，然后从左往右将桶中的元素依次提取出来作为新的数组，重复地在十、百、千、万...位上进行相同的操作。

- 适用于非负整数；
- 时间复杂度 $O(n)$ ；空间复杂度 $O(n)$ ；
- 是稳定的；
## 10.2 代码
```
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>
using namespace std;

void radixSort(vector<int>& nums) {
	const int bucketCount = 10;
	vector<list<int>> buckets(bucketCount);
	int maximum = *max_element(nums.begin(), nums.end());
	int temp = 0;
	while(maximum >> temp)
	{
		for (int i = 0; i < buckets.size(); i++)
			buckets[i].clear();

		for (int i = 0; i < nums.size(); i++)
			buckets[(nums[i] >> temp) % 10].push_back(nums[i]);
		temp++;

		int idx = 0;
		for (int i = 0; i < buckets.size(); i++)
			for (auto& ele : buckets[i])
				nums[idx++] = ele;
	} 
}

int main()
{
	//vector<int> nums = { 53, 3, 542, 748, 14, 214, 154, 63, 616 };
	vector<int> nums = { 73, 65, 22, 93, 43, 55, 14, 28, 65, 39, 99999999 };
	//vector<int> nums = { 70, 60, 20, 90, 40, 50, 10, 20, 60, 30, 99999990 };
	radixSort(nums);
	for (int i = 0; i < nums.size(); i++)
	{
		cout << nums[i] << endl;
	}
	system("pause");
	return 0;
}

//输出
14
22
28
39
43
55
65
65
73
93
99999999
```

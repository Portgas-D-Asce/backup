---
title: 堆排序
author: Portgas·D·Asce
categories:
- [Data Structure & Algorithm]
tags:
- 排序
date: 2020-03-18 23:59:43
---

堆排序（Heap Sort）

<!--more-->
## 1 理论
原理：利用堆数据结构所设计的一种排序算法。主要思路，首先先建好最大堆，然后迭代地执行 **交换堆顶和堆尾** 、 **堆大小减一** 、 **维护堆**，当堆的大小为一时，排序完成。

- 时间复杂度 $O(nlgn)$ ，空间复杂度 $O(1)$；
- 不稳定；
## 2 代码
```
#include <iostream>
#include <vector>
using namespace std;

int parent(int i) {
	return i - 1 >> 1;
}

int left(int i) {
	return (i << 1) | 1;
}

int right(int i) {
	return i + 1 << 1;
}

void heapfy(vector<int>& nums, int idx, int heapSize) {
	int l = left(idx);
	int r = right(idx);
	int largest = idx;
	if (l < heapSize && nums[l] > nums[largest])
		largest = l;
	if (r < heapSize && nums[r] > nums[largest])
		largest = r;
	if (largest != idx)
	{
		swap(nums[idx], nums[largest]);
		heapfy(nums, largest, heapSize);
	}
}

//对每个内部节点执行维护堆
void buildHeap(vector<int>& nums) {
	for (int i = nums.size() - 2 >> 1; i >= 0; i--)
		heapfy(nums, i, nums.size());
}

void heapSort(vector<int>& nums) {
	buildHeap(nums);
	for (int i = nums.size() - 1; i > 0; i--)
	{
		swap(nums[0], nums[i]);
		heapfy(nums, 0, i);
	}
}

int main()
{
	vector<int> nums = { 1,3,2,8,5,4,7,9,7,7,5,6 };
	heapSort(nums);
	for (int i = 0; i < nums.size(); i++)
		cout << nums[i] << endl;

	system("pause");
    return 0;
}

//输出
1
2
3
4
5
5
6
7
7
7
8
9
```
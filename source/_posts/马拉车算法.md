---
title: 马拉车算法
categories:
  - [Data Structure & Algorithm]
tags:
  - 字符串
  - 马拉车算法
date: 2019-12-26 09:58:44
---



Manacher's alorithm, you must know.
<!-- more -->
## 1 问题描述
给定一个字符串，求其最长的 **连续** 回文子串。

## 2 一些方法
### 2.1 judge all substrings
可以先找到所有连续子串，然后判断每个子串是否为回文，期间记录最长回文子串即可：
- 一个长度为 n 的字符串的连续子串的个数为： n(n + 1) / 2 ；
- 判断字符串是否为回文时间复杂度为 $O(n)$;

因此，总的时间复杂度为 $O(n^3)$ 。

### 2.2 expand from center
以第 i 个字符为中心，向两边扩展，即可得到：以第 i 个字符为中心的最长回文（时间复杂度为 $O(n)$），对每个字符进行同样的操作（总共需执行n次），期间记录下最长回文即可。

显然，总的时间复杂度为 $O(n^2)$ 。

## 3 马拉车算法（预处理）
### 3.1 连续子回文串长度必为奇数
在方案二中：
- 我们需要分别处理长度为奇数（eg，bcb）、长度为偶数（eg，bccb）的回文子串；

manacher通过对字符串预处理，巧妙地避开了这个问题：
- 在每个字符左右两侧都加上特殊字符（不存在于原字符串中的字符，这里使用 '#'）；
- 原字符串："acbcd";
- 预处理后字符串："#a#c#b#c#d#";

通过这样的预处理，使得连续回文子串长度只能为奇数，因此，完全不必讨论偶数情况；

### 3.2 再加一个东西
先知道有这一步就行（后面用到会解释）
- 在预处理后的字符串左侧再加上另一个特殊字符（不存在于原字符串中的字符，这里使用'$'）
- "#a#c#b#c#d#" 变为 "$#a#c#b#c#d#"

### 3.3 回文子串长度
为了避免绕口，先做如下声明：
- 预处理字符串中的连续回文子串用：pp表示（第一个p指的是预处理，第二个p指的是回文串），例如 "#b#c#b#" ；
- 原字符串中的连续回文子串用：sp表示（s指的是原字符串，p指的是回文串），例如 "bcb"；
- 两者是对应关系；

先观察以下两种情况：
- pp "#b#c#b#" 长度为7，半径为4，其所对应的sp "bcb" 长度为3；
- pp "#b#c#c#b#" 长度为9，半径为5，其所对应的sp "bccb" 长度为4；

显然，两者之间有如下关系：
- pp中，#的个数（pp的半径）总是比其它字符的个数总和（sp的长度）多一；
- 因此，sp长度 == pp半径 - 1；

### 3.3 回文串起始索引
知道了sp的长度，我们还需要知道它的起始索引，这样才能截取到sp。这里分别以字符串"ambcbdn" 和 "ambccbdn"为例：

注意：
- 为了不看花眼，特意在字符串中加了空格；

"cambcbdn" （最长sp为奇数情况）：
- 预处理后为："$#c#a#m #b# c #b# d#n#"；
- 最长pp：#b#c#b#，半径为4，其中心字符为'c'索引为10；
- 最长sp：bcb，起始索引为 (10 - 4) / 2 = 3;

"ambccbdn"（最长sp为偶数情况）：
- 预处理后为："$#a#m #b#c # c#b# d#n#"；
- 最长pp为：#b#c#c#b#，半径为5，其中心字符为'#'索引为9；
- 最长sp：bccb，起始索引为 (9 - 5) / 2 = 2;

结论：
- sp起始索引为：（pp中心字符索引 - pp半径）/ 2；

### 3.4 小结一下
步骤：
- 加#；
- 加$；
- 计算最长pp（马拉车算法核心，后面说），其所对应的 sp 即为我们所求的最长连续回文子串；
    - 最长pp半径：r ；中心字符索引：c ；
    - 最长sp长度：r - 1；
    - 最长sp起始索引：(c - r) / 2；
- 有了最长sp的起始索引 和 长度，我们就可以很容易地裁剪原字符串得到结果（最长连续子回文串）。

## 4 马拉车算法（核心）
马拉车的核心：如何计算最长pp？
### 4.1 变量含义
第一次了解这个算法，可能有点晦涩难懂的两个重要的辅助变量 mx 和 id：
- id为能延伸到最右端的位置的那个连续回文子串的中心点位置（因为pp的长度全为奇数，所以一定有中心点位置）；
- mx是连续回文子串能延伸到的最右端位置；

其它变量含义：
- p[id]，以索引id为中心的最长pp的半径；
- i：当前访问字符的索引；
- j：i 关于 id 的对称位置（即，j = 2 * id - i）；

### 4.2 核心一行
正如下面参考文件里面说的：“这行要是理解了，马拉车也就没啥问题了”。
```
p[i] = mx > i ? min(p[2 * id - i], mx - i) : 1;
```
当mx <= i 时：i 处于 mx 右端，没有什么可用信息，只能默认以 i 为中心的最长pp（pp_i）长度为1；

当mx > i 时：i 在mx延伸范围内，存在可用信息：
- 当mx - i > p[j] 时，以 j 为中心的最长pp（pp_j）被包含在以 id 为中心的最长pp内（pp_id），根据对称，以 i 为中心的最长pp（pp_i）也包含在pp_id内，p[i] = p[j]，如下图所示：

{%asset_img 1.png%}

- 当mx - i <= p[j] 时，根据对称，我们只能假设pp_i的最大半径为 mx - i，无法做更多假设，如下图所示：

{%asset_img 2.png%}

## 5 马拉车算法（代码）
```
#include <string>
#include <vector>
string process(string s){
    string res = "$#";
    for(int i = 0; i < s.size(); ++i)
    {
        //这样写不行的
        //res += s[i] + "#";
        res += s[i];
        res += '#';
    }
    return res;
}

string manacher(string s){
    string t = process(s);
    vector<int> p(t.size(), 0);
    int mx = 0;
    int id = 0;
    int r = 0;
    int c = 0;
    for(int i = 1; i < t.size(); ++i)
    {
        p[i] = mx > i ? min(p[2 * id - i], mx - i) : 1;
        //@的唯一用途在这里！有哨兵的味道
        //左侧不会出现数组越界情况
        //那怎么解释右侧也不会数组越界呢？
        //哈哈，不知道了吧
        //字符串后面有一个结束符的！！！
        while(t[i + p[i]] == t[i - p[i]])
            ++p[i];
        if(mx < i + p[i])
        {
            mx = i + p[i];
            id = i;
        }
        if(p[i] > r)
        {
            r = p[i];
            c = i;
        }
    }
    return s.substr((c - r) / 2, r - 1);
}
```
## 6 马拉车算法（时间复杂度）
看了代码之后，接下来分析下它的时间复杂度为什么是 O(n)

如果去掉下面代码，其它部分时间复杂度显然是 O(n)：
```
while(t[i + p[i]] == t[i - p[i]])
        ++p[i];
```
单独考虑上述代码：
- 由于其每执行一次，会将mx值推进一格，t的长度为 O(n)，因此，上面的循环总共执行 O(n) 次，其时间复杂度也就为 O(n)。

因此，马拉车算法的最终复杂度也就是 O(n)。
## 7 练习题
[LeetCode 5. Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/)
[LeetCode 647. Palindromic Substrings](https://leetcode.com/problems/palindromic-substrings/)
## 8 参考文献
[马拉车算法](https://blog.csdn.net/qq_40859951/article/details/87966123)

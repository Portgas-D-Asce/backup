---
title: 希尔排序
author: Portgas·D·Asce
categories:
- [Data Structure & Algorithm]
tags:
- 排序
date: 2020-03-18 23:59:55
---

希尔排序（Shell Sort）
<!-- more-->
## 1 理论
原理：当数据的 **有序程度** 越高，插入排序算法效率越高，基于这一特点，希尔排序对插入排序进行了改进：根据 **增量** 将数据划分为若干小组，然后通过对每一小组进行插入排序（由于数据量较小，插入效率高）提高数据的有序程度；按着 **增量序列** ，依次减小增量，并重复上述步骤，直到增量大小为1，即完成排序。

- 希尔排序时间复杂度分析极其复杂，增量序列不同，时间复杂度不同：
	- $1，2，...，2^n$ ，这种序列并不是很好的增量序列，使用这个增量序列的时间复杂度（最坏情形）是 $O(n^2)$ ；
	- 增量序列 $1,3,7，...,2^{k-1}$ ，的时间复杂度(最坏情形)为$O(n^{1.5})$ ；
- 空间复杂度$O(1)$ ;
- 不稳定；
- 对各组进行插入排序地时候，并不是先对一个数组插入排序完成，再对另一个数组进行插入排序，而是轮流地对各数组进行插入排序；
## 2 代码
```
#include <iostream>
#include <vector>

using namespace std;

void shellSort(vector<int>& nums) {
	int gap = nums.size();
	for (int gap = nums.size() / 2; gap > 0; gap /= 2)
	{
		for (int i = gap; i < nums.size(); i++)
		{
			int inserting = nums[i];
			int j = i - gap;
			while (j >= 0 && nums[j] > inserting)
			{
				nums[j + gap] = nums[j];
				j -= gap;
			}
			nums[j + gap] = inserting;
		}
	}
}
int main()
{
	vector<int> nums = { 1,5,3,4,2,9,6,0,3,4 };
	shellSort(nums);
	for (auto ele : nums)
	{
		cout << ele << endl;
	}
	system("pause");
    return 0;
}

//输出
0
1
2
3
3
4
4
5
6
9
```
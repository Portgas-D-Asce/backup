---
title: 二叉树遍历
author: Portgas·D·Asce
categories:
  - [Data Structure & Algorithm]
tags:
  - 树
date: 2020-08-29 00:25:34
---

二叉树遍历问题汇总。
<!-- more -->
## 1 理论
**1、二叉树遍历方法**
- 先序遍历遍历顺序：根--左--右
- 中序遍历遍历顺序：左--根--右
- 后序遍历遍历顺序：左--右--根
- 层序遍历遍历顺序：从上到下，从左到右

**2、二叉树还原**
- 已知**先序遍历序列**和**中序遍历序列**，可以唯一确定一颗二叉树 
- 已知**中序遍历序列**和**后序遍历序列**，可以唯一确定一颗二叉树 
- 已知**先序遍历序列**和**后序遍历序列**，**不** 能唯一确定一颗二叉树 

**3、节点**
```cpp
struct TreeNode {
	int val;
	TreeNode *left;
	TreeNode *right;
	TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};
```
## 2 先序遍历
```cpp
//递归
void preorder_recursion(TreeNode* node) {
	if(!node) return;
	//cout << node->val << endl;

	preorder_recursion(node->left);
	preorder_recursion(node->right);
}

//迭代
void preorder_iteration(TreeNode* root) {
	//考虑下为什么不先判断下root是否为空
    stack<TreeNode*> s;
    s.push(root);
    while(!s.empty())
    {
        if(root)
        {
            //cout << root->val << endl;
            
            if(root->right)
                s.push(root->right);
            root = root->left;
        }
        else
        {
            root = s.top();
            s.pop();
        }
    }
}
```

## 3 中序遍历
```cpp
//递归
void inorder_recursion(TreeNode* node) {
	if(!node) return;

	inorder_recursion(node->left);
	//cout << node->val << endl;
	inorder_recursion(node->right);
}

//迭代
void inorder_iteration(TreeNode* root) {
    stack<TreeNode*> s;
    //root仅仅有两次作用，最开始 和 遍历root的时候
    //放在后面利用 或 短路 一定程度上加速
    while(!s.empty() || root)
    {
        if(root)
        {
            s.push(root);
            root = root->left;
        }
        else
        {
            root = s.top();
            s.pop();  
            //输出root->val
                
            root = root->right;
        }
    }
}
```
## 4 后序遍历
```cpp
//递归
void postorder_recursion(TreeNode* node) {
	if(!node) return;

	postorder_recursion(node->left);
	postorder_recursion(node->right);
	//cout << node->val << endl;
}

//迭代1
//考虑到右子节点一定是在当前父节点前一个被遍历到
//一种代替标记的有效方法
void postorder_iteration(TreeNode* root) {
	if (!root) return;
	stack<TreeNode*> toVisit;
	toVisit.push(root);
	TreeNode* visiting = root->left;
	TreeNode* lastPop = NULL;
	while (visiting || !toVisit.empty())
	{
		//找到没有左子节点的节点  或  左子节点已经弹出的节点
		while (visiting)
		{
			toVisit.push(visiting);
			visiting = visiting->left;
		}
		visiting = toVisit.top();

		//如果右子节点不存在  或  右子节点已弹出
		if (!visiting->right || visiting->right == lastPop)
		{
			toVisit.pop();

			//cout << visiting->val << endl;

			lastPop = visiting;
			visiting = NULL;
		}
		//右子节点存在，且未被弹出
		else
		{
			visiting = visiting->right;
		}
	}
}

//迭代2（这实现，有点不要脸啊，哈哈）
//本质是先序遍历，结果是后序遍历
//但空间复杂度为O(n)
void postorderIteration(TreeNode* root) {
	if (!root) return;
    vector<int> postorder;
	
	stack<TreeNode*> toVisit;
	toVisit.push(root);
	while (!toVisit.empty())
	{
		TreeNode* visiting = toVisit.top();
		toVisit.pop();
		postorder.push_back(visiting->val);
		if (visiting->left)
		{
			toVisit.push(visiting->left);
		}
		if (visiting->right)
		{
			toVisit.push(visiting->right);
		}
	}
	reverse(postorder.begin(), postorder.end());
	/*for (auto ele : postorder)
		cout << ele << endl;*/
	
}
```
## 5 层序遍历
```cpp
//层序输出即可
void level_traversal(TreeNode* root) {
    if(!root) return;
    queue<TreeNode*> toVisit;
    toVisit.push(root);
	while (!toVisit.empty()) 
	{
		TreeNode* visiting = toVisit.front();
		toVisit.pop();
        //cout << visiting->val << endl;
		if (visiting->left)
			toVisit.push(visiting->left);
		if (visiting->right)
			toVisit.push(visiting->right);
	}
}

//按行打印
void line_print(TreeNode* root) {
	if(!root) return;
	queue<TreeNode*> q;
    q.push(root);
    while(!q.empty())
    {
        //important
        int n = q.size();
        for(int i = 0; i < n; ++i)
        {
            //cout << q.front()->val << "   ";
            if(q.front()->left)
                q.push(q.front()->left);
            if(q.front()->right)
                q.push(q.front()->right);
            q.pop();
        }
        //cout << endl;
    }
}

//"之" 字形打印二叉树
void zline_print(TreeNode* root) {
	if(!root) return res;
	queue<TreeNode*> q;
    q.push(root);
    bool flag = false;
    while(!q.empty())
    {
        int n = q.size();
        vector<int> temp;
        for(int i = 0; i < n; ++i)
        {
            temp.push_back(q.front()->val);
            if(q.front()->left)
                q.push(q.front()->left);
            if(q.front()->right)
                q.push(q.front()->right);
            q.pop();
        }
        if(flag) reverse(temp.begin(), temp.end());
        flag = !flag;
        /*for(int i = 0; i < n; ++i)
            cout << temp[i] << "   ";
        cout << endl;*/
    }
}
```
## 6 二叉树还原
```
//以先序 + 中序为例
TreeNode* recursion(vector<int>& pre, int preB, int preE, vector<int>& in, int inB, int inE){
    TreeNode* root = nullptr;
    if(preB <= preE)
    {
        root = new TreeNode(pre[preB++]);
        for(int i = inB; i <= inE; i++)
        {
            if(in[i] == root->val)
            {
                TreeNode* left = recursion(pre, preB, preB + i - inB - 1, in, inB, i - 1);
                TreeNode* right = recursion(pre, preB + i - inB, preE, in, i + 1, inE);
                root->left = left;
                root->right = right;
                break;
            }
        }
    }
    return root;
}
TreeNode* reConstructBinaryTree(vector<int>& pre,vector<int>& in) {
    return recursion(pre, 0, pre.size() - 1, in, 0, in.size() - 1);
}
```
## 7 二叉树序列化与反序列化
//待续
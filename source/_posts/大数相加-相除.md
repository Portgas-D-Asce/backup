---
title: 大数相加/相除
author: Portgas·D·Asce
categories:
  - []
tags:
  - null
date: 2020-10-29 17:03:47
---

## 1 大数相加
```cpp
string add(string &s1, string &s2) {
    //反转: 方便 相加 和 补零
    reverse(s1.begin(), s1.end());
    reverse(s2.begin(), s2.end());

    //补零
    int n = max(s1.size(), s2.size());
    string &t = s1.size() < s2.size() ? s1 : s2;
    t += string(n  - t.size(), '0');

    //相加
    int carry = 0;
    for(int i = 0; i < n; ++i) {
        carry += s1[i] - '0' + s2[i] - '0';
        s1[i] = carry % 10 + '0';
        carry /= 10;
    }

    //进位
    if(carry) s1 += '1';

    //反转回来
    reverse(s1.begin(), s1.end());

    return s1;
}
```

## 2 大数相乘
同大数相加一样，大数相乘也是模拟乘法竖式实现的：
- 长度分别为 $m$, $n$ 的两个数，它们乘积的位数不会超过 $m + n$，于是可以申请一个长度为 $m + n$ 的字符串来存储乘积；
- 第一个数的第 $i$ 和 第二个数的第 $j$ 位，所乘的结果应存放在乘积数组的第 $i + j + 1$ 位（0 indexed）；

为了直观感受第二点内容，这里以 $123456 * 123$ 为例来模拟一下：
```c
//注释表示索引

//      0 1 2 3 4 5
        1 2 3 4 5 6
//            0 1 2
              1 2 3
-------------------
        3 7 0 3 6 8
      2 4 6 9 1 2
    1 2 3 4 5 6
-------------------
    1 5 1 8 5 0 8 8
//0 1 2 3 4 5 6 7 8
```

```cpp
string multiply(string s1, string s2) {
    if(s1 == "0" || s2 == "0") return "0";

    int m = s1.size(), n = s2.size();
    string product(m + n, '0');
    while(int i = m - 1; i >= 0; --i)
    {
        int carry = 0;
        int p = s1[i] - '0';
        for(int j = n - 1; j >= 0; --j)
        {
            int r = s2[j] - '0';
            int temp = product[i + j + 1] - '0' + p * r + carry;
            product[i + j + 1] = temp % 10 + '0';
            carry = temp / 10;
        }
        //进位别忘了
        product[i] = carry + '0';
    }

    //乘积的位数 <= m + n
    int idx = product.find_first_not_of('0');
    return product.substr(idx);
}
```

## 练习
[LeetCode 43. Multiply Strings](https://leetcode.com/problems/multiply-strings/)

[LeetCode 415. Add Strings](https://leetcode.com/problems/add-strings/)
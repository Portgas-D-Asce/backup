---
title: 桶排序
categories:
- [Data Structure & Algorithm]
tags:
- 排序
date: 2020-03-19 00:00:15
---

桶排序（Bucket Sort）
<!--more-->
## 1 原理
原理：在假设数组中元素均匀分布的前提下，先把原数组元素划到 $n$ （$n$ 为数组大小）个 **大小相同的桶** 中，且一定要保证 **左侧桶中数字大于右侧桶中元素**，然后对每个桶中元素各自进行排序，最后从左到右将所有桶中元素合并即可完成排序。

- 当所有桶大小的平方和与总的元素数成线性关系时，时间复杂度为 $O(n)$；空间复杂度为 $O(n)$；
- 桶的个数最好为 $n$ ：当桶的个数较少时，桶内元素个数普遍增加，导致各自排序耗时快速上升，进而使效率降低；当桶的个数较多时，会造成空间的浪费；有时为了避免数组越界，需要将桶的个数调整为 $n + 1$；
- 适用于整数和浮点数的桶排序实现，略有不同：针对整数，保持桶个数不变，桶大小 $+1$ ；针对浮点数，保持桶的大小不变，桶的个数  $+1$；
- 稳定性取决于链表排序的稳定性；
## 2 代码
```
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>
using namespace std;

void bucketSort(vector<int>& nums) {
	int maximum = *max_element(nums.begin(), nums.end());
	int minimum = *min_element(nums.begin(), nums.end());

	
	//若用于整数排序，桶大小 +1
	//bucketSize 的值为 (maximum - minimum) / nums.size()的值向上取整或直接加一（当能整除时）
	//所以可以保证(nums[i] - minimum) / bucketSize不会发生数组越界
	vector<list<int>> buckets(nums.size());
	int bucketSize = (maximum - minimum) / nums.size() + 1;
	
	//若用于浮点数排序，桶个数 + 1
	//当nums[i]取最大值时， (nums[i] - minimum) / bucketSize可能会发生数组越界
	//为了避免数组越界，这里采用的策略是将桶的个数加一
	//为什么不是将桶的大小加一的原因是：数组最大最小值之差可能是一个小于 1 的数，桶大小贸然加一会使得所有元素都放在一个桶中
	//因此，桶的个数加一更好
	//vector<list<int>> buckets(nums.size() + 1);
	//double bucketSize = (maximum - minimum) / nums.size();

	for (int i = 0; i < nums.size(); i++)
		buckets[(nums[i] - minimum) / bucketSize].push_back(nums[i]);

	for (int i = 0; i < buckets.size(); i++)
		buckets[i].sort();

	for (int i = 0, idx = 0; i < buckets.size(); i++)
		for (auto ele : buckets[i])
			nums[idx++] = ele;
}

int main()
{
	vector<int> nums = { -1,-10,5,-3,7,10,15,-3,15,18,9,-7,-13 };
	bucketSort(nums);
	for (int i = 0; i < nums.size(); i++)
	{
		cout << nums[i] << endl;
	}
	system("pause");
    return 0;
}

//输出
-13
-10
-7
-3
-3
-1
5
7
9
10
15
15
18
```

---
title: 计数排序
author: Portgas·D·Asce
categories:
- [Data Structure & Algorithm]
tags:
- 排序
date: 2020-03-19 00:00:55
---

计数排序（Counting Sort）
<!--more-->

## 1 理论
**1、要点**

- 基本思想：对每一个输入元素 $x$ ，确定小于 $x$ 元素的个数，即可确定 $x$ 在排序数组中的位置；
- 输入元素均在 $0$ 到 $k$ 之间（或某一较小区间范围内），且为整数；
- 时间复杂度，空间复杂度均为 $O(k + n)$；
- 计数排序是稳定的：具有相同值得元素在输出数组中的相对次序与它们在输入数组中的相对次序是一致的；

**2、算法步骤（3 for）**

- 统计 **输入数组** 中， [0, k] 每个值出现的次数；
- 累加 **临时数组**，计算 [0, k] 中每个值在排序数组中的位置；
- 将 **输入数组** 中每个值，按照计算的对应位置插入到 **输出数组** 中；
```
//输入数组：A[1 .. n]，A.length = n
//输出数组：B[1 .. n]，B.length = n
//临时数组：C[0 .. k]，C.length = k + 1
COUNTING-SORT(A, B, k)
let C[0 .. k] be a new array;
for i = 0 to k
	C[i] = 0;
for j = 1 to A.length
	C[A[j]] = C[A[j]] + 1;
for i = 1 to k
	C[i] = C[i] + C[i - 1];
for j = A.length downto 1
	B[C[A[j]]] = A[j];
	C[A[j]] = C[A[j]] - 1;
```
## 8.2 代码
```
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

vector<int> countingSort(vector<int>& A) {
	int min = *min_element(A.begin(), A.end());
	int max = *max_element(A.begin(), A.end());

	vector<int> B(A.size());
	vector<int> C(max - min + 1, 0);
	for (auto num : A)	
		C[num - min]++;
	for (int i = 1; i < C.size(); i++)
		C[i] += C[i - 1];
	for (int i = A.size() - 1; i >= 0; i--)
		B[--C[A[i] - min]] = A[i];	
	return B;
}
int main()
{
	vector<int> A = { 9,8,7,6,5,20,6,6 };
	vector<int> B = countingSort(A);
	for (auto ele : B)
		cout << ele << endl;
	system("pause");
    return 0;
}
//输出
5
6
6
6
7
8
9
20
```

---
title: 大数相加/相乘
author: Portgas·D·Asce
categories:
  - [Data Structure & Algorithm]
tags:
  - Large Number
  - LeetCode
date: 2020-10-29 17:03:47
---

## 1 大数相加
```cpp
string add(const string &s1, const string &s2) {
    //短字符串补零
    const string &t1 = s1.size() > s2.size() ? s1 : s2;
    string t2 = s1.size() > s2.size() ? s2 : s1;
    t2 = string(t1.size()  - t2.size(), '0') + t2;

    //相加
    int carry = 0, n = t1.size();
    for(int i = n - 1; i >= 0; --i) {
        carry += t1[i] - '0' + t2[i] - '0';
        t2[i] = carry % 10 + '0';
        carry /= 10;
    }

    //进位（0 或 1）
    return carry ? "1" + t2 : t2;
}
```

## 2 大数相乘
同大数相加一样，大数相乘也是模拟竖式实现的：
- 长度分别为 $m$, $n$ 的两个数，它们乘积的位数不会超过 $m + n$，于是可以申请一个长度为 $m + n$ 的字符串来存储乘积；
- 第一个数的第 $i$ 和 第二个数的第 $j$ 位，所乘的结果应存放在乘积数组的第 $i + j + 1$ 位（0 indexed）；

为了直观感受第二点内容，这里以 $123456 * 123$ 为例来模拟一下：
```c
//注释表示索引

//      0 1 2 3 4 5
        1 2 3 4 5 6
//            0 1 2
              1 2 3
-------------------
        3 7 0 3 6 8
      2 4 6 9 1 2
    1 2 3 4 5 6
-------------------
    1 5 1 8 5 0 8 8
//0 1 2 3 4 5 6 7 8
```

```cpp
string multiply(const string &s1, const string &s2) {
    if(s1 == "0" || s2 == "0") return "0";

    //初始化
    int m = s1.size(), n = s2.size();
    string product(m + n, '0');

    //相乘
    for(int i = m - 1; i >= 0; --i)
    {
        int carry = 0;
        int p = s1[i] - '0';
        for(int j = n - 1; j >= 0; --j)
        {
            int r = s2[j] - '0';
            int temp = product[i + j + 1] - '0' + p * r + carry;
            product[i + j + 1] = temp % 10 + '0';
            carry = temp / 10;
        }
        //进位（不大于9）别忘了
        product[i] = carry + '0';
    }

    //乘积的位数 <= m + n
    int idx = product.find_first_not_of('0');
    return product.substr(idx);
}
```

## 练习
[LeetCode 43. Multiply Strings](https://leetcode.com/problems/multiply-strings/)

[LeetCode 415. Add Strings](https://leetcode.com/problems/add-strings/)
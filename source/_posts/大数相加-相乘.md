---
title: 大数加减乘除
author: Portgas·D·Asce
categories:
  - [Data Structure & Algorithm]
tags:
  - Large Number
  - LeetCode
date: 2020-10-29 17:03:47
---

## 1 大数相加
```cpp
string add(const string &s1, const string &s2) {
    //短字符串补零
    const string &t1 = s1.size() > s2.size() ? s1 : s2;
    string t2 = s1.size() > s2.size() ? s2 : s1;
    t2 = string(t1.size()  - t2.size(), '0') + t2;

    //相加
    int carry = 0, n = t1.size();
    for(int i = n - 1; i >= 0; --i) {
        carry += t1[i] - '0' + t2[i] - '0';
        t2[i] = carry % 10 + '0';
        carry /= 10;
    }

    //进位（0 或 1）
    return carry ? "1" + t2 : t2;
}
```

## 2 大数相乘
同大数相加一样，大数相乘也是模拟竖式实现的：
- 长度分别为 $m$, $n$ 的两个数，它们乘积的位数不会超过 $m + n$，于是可以申请一个长度为 $m + n$ 的字符串来存储乘积；
- 第一个数的第 $i$ 和 第二个数的第 $j$ 位，所乘的结果应存放在乘积数组的第 $i + j + 1$ 位（0 indexed）；

为了直观感受第二点内容，这里以 $123456 * 123$ 为例来模拟一下：
```c
//注释表示索引

//      0 1 2 3 4 5
        1 2 3 4 5 6
//            0 1 2
              1 2 3
-------------------
        3 7 0 3 6 8
      2 4 6 9 1 2
    1 2 3 4 5 6
-------------------
    1 5 1 8 5 0 8 8
//0 1 2 3 4 5 6 7 8
```

```cpp
string multiply(const string &s1, const string &s2) {
    if(s1 == "0" || s2 == "0") return "0";

    //初始化
    int m = s1.size(), n = s2.size();
    string product(m + n, '0');

    //相乘
    for(int i = m - 1; i >= 0; --i)
    {
        int carry = 0;
        int p = s1[i] - '0';
        for(int j = n - 1; j >= 0; --j)
        {
            int r = s2[j] - '0';
            int temp = product[i + j + 1] - '0' + p * r + carry;
            product[i + j + 1] = temp % 10 + '0';
            carry = temp / 10;
        }
        //进位（不大于9）别忘了
        product[i] = carry + '0';
    }

    //乘积的位数 <= m + n
    int idx = product.find_first_not_of('0');
    return product.substr(idx);
}
```

## 3 大数相除
```cpp
#include <iostream>
#include <string>
using namespace std;

int comp(const string &a, const string &b) {
    if(a == b) return 0;
    if(a.size() < b.size() || (a.size() == b.size() && a < b)) return -1;
    return 1;
}

//comp(a, b) != -1
string subtract(string a, string b) {
    if(a == b) return "";

    if(b.size() < a.size()) b = "0" + b;
    int n = b.size();
    int carry = 0;
    for(int i = n - 1; i >= 0; --i) {
        int temp = (a[i] - '0') + carry - (b[i] - '0');
        a[i] = (temp + 10) % 10 + '0';
        carry = temp < 0 ? -1 : 0;
    }
    int idx = a.find_first_not_of('0');
    return a.substr(idx);
}

string divide(const string &a, const string &b) {
    if(comp(a, b) == -1) return "0";

    int n = a.size(), m = b.size();
    string rem, res;
    for(int i = 0; i < n; ++i) {
        rem += a[i];
        //若没有, 10000 / 1 会出现bug
        if(rem == "0") rem = "";
        char temp = '0';
        while(comp(rem, b) != -1) {
            rem = subtract(rem, b);
            ++temp;
        }
        res += temp;
    }
    int idx = res.find_first_not_of('0');
    return res.substr(idx);
}

void check() {
    const int mx = 1000;
    for(int i = 1; i < mx; ++i) {
        for(int j = 1; j < i; ++j) {
            int expect = i / j;
            int real = stoi(divide(to_string(i), to_string(j)));
            if(expect != real) {
                cout << "your program exists bugs when dealing " << i << " / " << j << endl;
                return;
            }
        }
    }
    cout << "there is nothing wrong with your program!" << endl;
}

int main() {
    //check();
    string a, b;
    while(cin >> a >> b) {
        if(b == "0") {
            cout << "divided by zero!" << endl;
            continue;
        }
        string res = divide(a, b);
        cout << res << endl;
    }
    return 0;
}
```

## 练习
[LeetCode 43. Multiply Strings](https://leetcode.com/problems/multiply-strings/)

[LeetCode 415. Add Strings](https://leetcode.com/problems/add-strings/)
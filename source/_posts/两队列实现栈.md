---
title: 两队列实现栈
categories:
- [Data Structure & Algorithm]
- [OJ, LeetCode]
tags:
  - 栈
  - 队列
date: 2020-03-19 01:23:21
---
Leetcode 225. Implement Stack using Queues
<!--more-->

**1、push**
- push到不为空的队列；
- 当两个都为空的时候，默认push到q1；

**2、pop**
- **虽然用了两个队列，但是无论什么时候，其中必有一个为空；**
- 每次pop实际上就是将元素（size - 1个）从 **非空的队列** 转移到 **空队列** 中，最后把空队列中剩余的最后一个元素删除掉即可；

**3、top**
- 同pop类似，需要将所有元素从非空队列转移到空队列中，期间记录下最后转移的元素作为输出；

**4、empty**
- 只有当两个队列都为空的时候，栈才为空；

**5、size**
- 不知道元素在哪个队列中，返回q1.size() 或 q2.size() 都不对，索性直接返回 q1.size() + q2.size()，总没错；
```
#include <queue>
using namespace std;

class MyStack {
private:
	queue<int> q1;
	queue<int> q2;
public:
	MyStack() {

	}

	void push(int x) {
		q2.empty() ? q1.push(x) : q2.push(x);
	}

	void pop() {
		q1.empty() ? moveTo(q2, q1, true) : moveTo(q1, q2, true);
	}

	int top() {
		return q1.empty() ? moveTo(q2, q1, false) : moveTo(q1, q2, false);
	}

	bool empty() {
		return q1.empty() && q2.empty();
	}
private:
	int moveTo(queue<int>& fil, queue<int>& emp, bool del) {
		while (fil.size() > 1)
		{
			emp.push(fil.front());
			fil.pop();
		}
		int res = fil.front();
		fil.pop();
		if (!del)
			emp.push(res);
		return res;
	}
};
int main()
{
	system("pause");
    return 0;
}
```
